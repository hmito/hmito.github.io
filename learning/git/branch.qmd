---
title: ブランチ
format:
    html:
        toc: true
execute:
    eval: false
---
```{r}
#| echo: false
#| eval: false
print("a")
```

ここからがgitの真髄です。このページでは、複数のバージョンを同時に管理するブランチの概念について説明します。

## 今どこにいるか？：HEAD
gitでは「現在のフォルダの中身は変更履歴上のどのタイミングのものか」、つまり**現在のフォルダの状態のことをHEADと呼びます**。HEADの位置は、GitGraph上では「○」で表示され、コミットメッセージが太字になります。

![](rsc/branch0.png)

HEADの位置を変えることで、フォルダの中身を丸ごと過去の状態に戻すことができます。この操作をcheckoutと呼びます。HEADの位置を変えるには、GitGraph上の**適当なコミットメッセージの上で右クリックし、「Checkout」**を選びます。警告が出ると思いますが、無視して「Yes, checkout」を選んでください。

![](rsc/branch0a.png)

すると、HEADを示す「○」の位置、太字のコミットが切り替わったはずです。エクスプローラーからファイルを開くと、ファイルの中身がこのコミット時点の状態に戻っているのが確認できるはずです。このように、**gitは任意の時点まで簡単にフォルダの中身を戻すことができます**。

ただし、**通常はこのような特定のコミットへのcheckoutを行うことはほとんどありません**。せいぜい「一時的に過去のファイルの中身を確認するため」に使われるくらいです。これは、gitのバージョン管理が**ブランチ**と呼ばれる仕組みと紐ついているためです。

## 履歴の枝分かれ：ブランチ
gitでは、新たなコミットは **ブランチ** と呼ばれる地点から行うのが基本です。文字通り、履歴の「枝」の先端、変更履歴の「生長点」のようなものです。

GitGraphで見ると、最新のコミットに main と書かれたラベルがついています。これは、これまで伸ばしてきた変更履歴が、mainという名前のブランチから行われてきたことを示しています。

![](rsc/branch1.png)

ブランチを必要に応じて自由に作ることができます。**新しくブランチを作るには、GitGraph上で適当なコミットのメッセージ上で右クリックし、Create Branchを選択します**。ポップアップに適当な名前を入力して「create branch」を選ぶと、新たなブランチが作成されます。

![](rsc/branch1a.png)

現在のフォルダの状態**HEADは、GitGraph上でブランチのラベルをダブルクリック**することで切り替えることができます。HEADがあるブランチは、ブランチラベルが太字になります。画面下ステータスバーの左端にも現在HEADがあるブランチが表示されています。

![](rsc/branch2.png)

新たなコミットは、現在HEADがあるブランチに対して反映されます。例えば、先ほど作成した「kibidango」ブランチにHEADがある状態で新たな変更をコミットすると、kibidangoブランチが一つ進み、mainブランチと履歴が「枝分かれ」します。

![](branch3.png)

このように、ブランチごとに変更履歴を管理できる、つまり複数のバージョンを同時に管理できるのがgitの持つ重要な機能の一つです。


:::{.callout-note}
### HEAD≠コミット上の位置
上ではHEADの位置はコミット上のどこにあるか、のように説明してきましたが、正確にはHEADの位置は「コミット」の場合と「ブランチ」の場合、両方があります。

例えば、ブランチのラベルをダブルクリックせず、そのブランチがあるコミットをcheckoutすると、HEADはコミット上にある状態になります。この時、ブランチ名は太字にならず、ステータスバーにもブランチ名が表示されません（代わりにコミットIDと呼ばれる16進数が表示されています）。

![](rsc/branch2a.png)

これは、HEADが単にコミットの位置情報なのではなく、「今から行う変更はどのブランチに反映するか」を決めるものだからです。わかりやすいのは複数のブランチが同一のコミット上にある場合でしょうか。以下の例の場合、「kibidango」ブランチと「onitaiji」ブランチが両方同じコミット上にあり、この例ではonitaijiブランチ上にHEADがあることがわかります。この場合、新たなコミットはonitaijiブランチに追加されます。

![](rsc/branch2b.png)

逆に、HEADがブランチにない状態でコミットした場合、そのコミットはどのブランチにも反映されない非常にあいまいな状態となります。このため、基本的にHEADは常にいずれかのブランチにある状態にしておくのが望ましいとされています。

:::

## ブランチに基づく開発
ブランチを用いることで、複数のバージョン管理ができることは分かったかと思います。しかし、そもそもブランチはどのような場合に利用するのでしょうか。

多くのプロジェクトでは、試行錯誤を繰り返す「開発」の段階と、実際に使用する「運用」の段階がしばしばあります。しかし、このような異なる段階におけるコミットが一本の履歴上にあると以下のような問題が起きます。

- 複数の目的の変更を同時進行で進めると、それぞれ異なる目的の変更が混ざってしまう
- 「いつどんな目的でこれらの変更が行われているのか」が変更履歴からわかりにくくなる
- ある機能に関する変更が、ほかの機能にも影響を与えてしまい、運用したいのに動かなくなってしまう

この問題を解決するために考え出されたのが、ブランチを用いた開発手法です。gitでは、
基本的に新しいアイデアを試す際には、それ専用のブランチを作ります。

gitでは、このような**履歴の枝分かれ一つ一つをブランチ branch** と呼びます。gitでは、履歴は基本的に

## マージ

## コンフリクト

## チェリーピック



前ページで作成したリポジトリを


```{=html}
<div class="prev-next-link">
    <a class="prev-link" href="commit.html">
        <p class="prev-next-label">prev</p>
        <p>コミットと変更履歴</p>
    </a>
    <a class="next-link" href="branch.html">
        <p class="prev-next-label">next</p>
        <p>サーバーとの同期</p>
    </a>
</div>
```