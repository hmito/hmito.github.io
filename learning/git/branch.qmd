---
title: ブランチ
format:
    html:
        toc: true
execute:
    eval: false
---
```{r}
#| echo: false
#| eval: false
print("a")
```

このページでは、複数のバージョンを同時に管理するために不可欠なgitの中心的概念の一つ、「ブランチ」について説明します。

## 今どこにいるか？：HEAD
gitでは「現在のフォルダの中身は変更履歴上のどのタイミングのものか」、つまり**現在のフォルダの状態のことをHEADと呼びます**。HEADの位置は、GitGraph上では「○」で表示され、コミットメッセージが太字になります。

![](rsc/branch0.png){width=500}

HEADの位置を変えることで、フォルダの中身を丸ごと過去の状態に戻すことができます。この操作をcheckoutと呼びます。HEADの位置を変えるには、GitGraph上の**適当なコミットメッセージの上で右クリックし、「Checkout」**を選びます。警告が出ると思いますが、無視して「Yes, checkout」を選んでください。

![](rsc/branch0a.png){width=500}

すると、HEADを示す「○」の位置、太字のコミットが切り替わったはずです。エクスプローラーからファイルを開くと、ファイルの中身がこのコミット時点の状態に戻っているのが確認できるはずです。このように、**HEADの位置を動かすことで、gitは任意の時点のフォルダを簡単に復元することができます**。試しに、いくつかのコミットをチェックアウトして、最新の状態から一番最初の状態まで、フォルダの中身を切り替えられることを確認してください。

checkoutを使ってHEADを動かせばフォルダの中身を巻き戻すことはできますが、実は普段の操作では特定のコミットへのcheckoutはほとんど行うことはありません。これは、gitには**ブランチ**と呼ばれるより便利な仕組みがあるためです。

## 履歴の枝分かれ：ブランチ
ここまで、コミットは一本の履歴上に連なっていました。しかし、このような履歴が一本道の構造だと以下のような問題が起きます。

- ある機能のために変更したら、他の機能にも影響を与えて動かなくなってしまった
- ある機能の開発のために行われた変更がどれなのか、変更履歴から見つけにくい
- バグが発生したことに気づいたが、いろいろ触りすぎていてどの変更が原因かわかりにくい

これらの問題は、「安定して利用したい」「バグを治したい」「新しい機能を追加したい」など、異なる目的での変更作業をすべて同じ履歴の中で行ってしまっていることが原因です。

そこで、gitでは**目的ごとに作業環境を丸ごと切り替えるための機能**として、**ブランチ**が用意されています。イメージとしては「機能A開発用の環境」「機能B開発用の環境」「バグの修正環境」「計算に使う安定版環境」それぞれにブランチを用意し、目的に応じて切り替えながら履歴を伸ばしていくような使い方です。

GitGraphで見ると、最新のコミットに main と書かれたラベルがついています。実は、これまではデフォルトの「main」という名称のブランチを利用していました。

![](rsc/branch1.png){width=500}

ブランチは必要に応じて自由に作ることができます。ブランチを作る際には、まず作業環境として履歴上のどのタイミングのフォルダ状態（すなわち、どのコミット）から始めるかを選択します。**新しくブランチを作るには、GitGraph上で選択するコミットのメッセージ上で右クリックし、Create Branchを選択します**。ポップアップに適当な名前を入力して「create branch」を選ぶと、新たなブランチが作成されます。

![](rsc/branch1a.png){width=500}

:::{.callout-note}
新たなブランチを作成することを、俗に「ブランチを切る」とも呼びます。
:::

現在のフォルダの状態**HEADは、GitGraph上でブランチのラベルをダブルクリック**することで切り替えることができます。HEADがあるブランチは、ブランチラベルが太字になります。画面下ステータスバーの左端にも現在HEADがあるブランチが表示されています。checkoutを使ったとき同様、フォルダの状態もブランチの切り替えと同時に変わっていることを確認してください。

![](rsc/branch2.png){width=500}

新たなコミットは、現在HEADがあるブランチに対して反映されます。例えば、先ほど作成した「kibidango」ブランチにHEADがある状態で新たな変更をコミットすると、kibidangoブランチが一つ進み、mainブランチと履歴が「枝分かれ」します。つまり、kibidangoブランチ上では、mainブランチには影響を与えることなく、編集しコミットを行えるわけです。

![](rsc/branch3.png){width=500}

このように、**ブランチは目的ごとの「作業環境」として機能**します。目的ごとにブランチを作成することで、他のブランチには影響を与える心配をせず、その目的に集中して更新作業を行うことができるわけです。

:::{.callout-tip}
### HEAD≠コミット上の位置
上でも少し触れましたが、HEADの位置は「コミット」の場合と「ブランチ」の場合、両方があります。

例えば、ブランチのラベルをダブルクリックせず、そのブランチがあるコミットをcheckoutすると、HEADはコミット上にある状態になります。この時、ブランチ名は太字にならず、ステータスバーにもブランチ名が表示されません（代わりにコミットIDと呼ばれる16進数が表示されています）。

![](rsc/branch2a.png){width=500}

これは、HEADが単にコミットの位置情報なのではなく、「今から行う変更はどのブランチに反映するか」を決めるものだからです。わかりやすいのは複数のブランチが同一のコミット上にある場合でしょうか。以下の例の場合、「kibidango」ブランチと「onitaiji」ブランチが両方同じコミット上にあり、この例では「onitaiji」ブランチ上にHEADがあることがわかります。この場合、新たなコミットは「onitaiji」ブランチに追加されます。

![](rsc/branch2b.png){width=500}

このように、ブランチの選択はコミットを置く先の選択という点でも重要です。

なお、**HEADがブランチにない状態でもコミット自体は可能ですが、この状態でのコミットは履歴が孤立しやすく、後で見失う可能性があるため、通常は避けるべきです（後述）**。特定のコミットへのcheckoutは、せいぜい「一時的に過去のファイルの中身を確認するため」に使うくらいにとどめ、原則として通常はHEADはブランチに置きましょう。新たにHEADにしたいコミットが存在するなら、多くの場合そのコミットに新たなブランチを作成すべきです。

:::

## マージとチェリーピック

上述の通り、あるブランチにおけるコミットは、そのままでは他のブランチには反映されません。あるブランチにおける変更を別のブランチにも反映するには、二つの方法があります。

### マージ

一つは、**マージ merge** と呼ばれる方法です。これは、**あるブランチが現在のブランチと分岐後に行われた全てのコミットを現在のブランチに取り込む**操作です。つまり、二つのブランチの分岐点からの変更がすべて取り込まれます。

マージの操作は以下の通りです。

1. まず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）
2. 次に、取り込みたい**ブランチタグを右クリック**し、「Merge into current branch」を選択

![](rsc/merge1.png){width=500}

3. Merge用の小さな画面が開く。上部に「... merge branch マージされるブランチ into 現在のブランチ」と表示されていることを確認して、「Yes, merge」を選択

![](rsc/merge2.png){width=500}

この操作で、自動的に「Merge branch ...」というメッセージを持つ**マージコミット**と呼ばれるコミットが作成されます。マージコミットの左側では、マージされた側のブランチからマージしたブランチへと合流するラインがひかれます。マージコミットの中身を確認すると、マージされる側において分岐後に行われた全てのコミット（下の例では「黍団子のレシピの追加」と「おじいいさんおばあさんの黍団子の描写を追加」の二つのコミット）の内容が含まれているはずです。

![](rsc/merge3.png){width=500}

:::{.callout-note}
エラーメッセージが表示された場合は、次の[コンフリクト](#マージの中止)を確認してみてください。
:::

このように、マージは特定のブランチにおける変更を丸ごと取り込むために使用されます。マージされたあとのブランチには、それまでに両方のブランチで行われた変更すべてが含まれており、文字通り二つのブランチを「合併」したものとなります。

### チェリーピック

もう一つは、**チェリーピック cherry pick** と呼ばれる方法です。これは、**あるブランチにおける特定のコミットのみを現在のブランチに取り込む**操作です。

:::{.callout-note}
### cherry pick = つまみ食い
cherry pickとは、サクランボの熟したものだけを選んで食べる様から転じて、「つまみ食い」を意味する表現です。まさに、ほかのブランチにある特定のコミットだけつまみ食いしているわけです。
:::

チェリーピックの操作は以下の通りです。

1. まず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）
2. 次に、取り込みたいコミットのメッセージなど、**ブランチタグ以外のエリアを右クリック**し、Cherry Pickを選択

![](rsc/cherrypick1.png)

3. cherry pick用の小さな画面が開くので、「Yes, cherry Pick」を選択

この操作で、取り込みたいコミットがコミットメッセージなども新たに現在のブランチに追加されたはずです。しかし、マージのようなブランチの合流線は描かれません。

![](rsc/cherrypick2.png)

:::{.callout-note}
エラーメッセージが表示された場合は、次の[コンフリクト](#マージの中止)を確認してみてください。
:::

## 編集の競合：コンフリクト

### 同一箇所への編集によるコンフリクト

チェリーピックやマージは、二つの異なるブランチ間で行われた変更を統合する作業です。それでは、もし二つのブランチが同一のファイルを編集していた場合、どうなるでしょう？　この場合でも、変更が異なる箇所（例えばファイルの先頭と末尾）に行われている場合には、両方の変更がうまく残されます。しかし、もし**同一の箇所が変更されていたり、ファイル自体が削除されている場合では、編集の競合：コンフリクトが発生します。

コンフリクトが発生すると、以下のようなエラーメッセージが表示されます。

![](rsc/merge_conflict1.png){width=200}

「Dismiss」（却下）を選ぶと、マージコミットは作成されておらずマージ前に戻っているように見えますが、ソース管理画面ではすでにコミットメッセージが入力されており、その下部には「変更のマージ」というファイルがステージ済みのファイルなどとともに表示されているはずです。ここに記載されているファイルが、コンフリクトが発生したファイルです。クリックすると、コンフリクトの詳細を確認できます。

![](rsc/merge_conflict2.png){width=500}

コンフリクトの解決は簡単です。まず、コンフリクトが発生したファイルをクリックした際に右下に表示される「マージエディターで解決」を選択します。すると、「マージ：ファイル名」というタブが新たに開きます。

![](rsc/merge_conflict3.png){width=500}

この画面では、上部の左側にマージされる側のブランチ、右側に現在のブランチのファイルの状態が示されています。スクロールバーでは、コンフリクトが発生した位置が黄色く表示されています（上の例では3か所）。画面下部では、コンフリクトを解決した後のファイルが表示されます。解決は、以下のいずれかの方法をとります。

- どちらかの変更を反映したい場合、反映したい側で「（現在のマシン/受信中）を適用する」ボタンを押す
- 両方の変更を残したければ、両側で押すか、「組み合わせを宇井家入れる」を選ぶ
- どちらの変更も反映したくなければ、「無視する」を両側で選ぶ
- 画面下部で手動で編集して解決することもできる

解決済みになると、スクロールバー上の表示が黄色から灰色に変わります。全てのコンフリクトを解決後、画面右下の「マージを完了」を押します。これで、当該ファイルは「変更のマージ」から「ステージされている変更」に移動します。

他にもコンフリクトが発生しているファイルがあれば、同様の手順で解決します。すべてのファイルが「ステージされている変更」に移動したら、続行ボタンを押します。これで無事マージは終了です。

![](rsc/merge_conflict4.png){width=500}

### ファイルの削除に伴うコンフリクト

一方ではファイルが削除、または移動されてしまっていることによるコンフリクトが起きることもあります。この場合、ソース管理画面で「変更のマージ」にあるファイルを選んでも、「マージエディターで解決」ボタンは表示されません。

この場合は、ファイルを右クリックし「変更をステージ」を選んでください。ファイルを削除するか残すかを選択できます。

### マージの中止

コンフリクトが発生した場合、マージ自体を中止したいかもしれません。この場合、以下の手順でマージを中止できます。

1. GitGraphの上部右端にあるRefreshボタンを押す
2. 「Uncommitted Changes」という表示が履歴の最上部に現れるので、右クリックし「Reset Uncommitted Changes」を選ぶ
3. Resetの確認画面が表示されるので、「Mixed」ではなく「Hard」を選び、「Yes, reset」を選択する

![](rsc/merge_conflict5.png){width=500}

以上の手順で、マージ前の状態に戻すことができます。

### 不要なブランチの削除

マージによって、マージされる側のブランチが不要になった場合、**ブランチタグを右クリックし「Delete Branch」を選ぶことで削除**することができます。なお、現在HEADを置いているブランチは削除できないので、まず別のブランチにHEADを移してから削除しましょう。

なお、マージされておらず、ほかのブランチもない状態でブランチを削除すると、そこまでの履歴も一緒に消えてしまいます（正確には非表示になる：下記参照）。必ずほかのブランチにマージした後に削除してください。

:::{.callout-tip}
### 履歴が消える？
履歴の保存を目的としているgitでは、過去のコミットが消えてしまうことはほぼありません。しかし、過去のコミットすべてを表示していると、履歴表示が煩雑になることがあるため、gitでは基本的に「使用されない」コミットは非表示となります。具体的には、当該コミットより先にブランチがなく、タグ（特定のコミットに着けられるマーク、のちのページで扱います）もない状態では、非表示となります。

例えば、以下の状態で「kibidango」ブランチを削除すると、上の三つのコミットは非表示となります。これは、ブランチを削除したことで、これら三つのコミットの先にブランチがなくなってしまうためです。

![](rsc/branch_missed0.png){width=500}

同様の事故は、ブランチではなくコミットにHEADを置いている場合に良く起きます。以下の例では最初のコミットにHEADを置いてから、いくつかのコミットを追加した状態です。

![](rsc/branch2c.png){width=500}

この状態では、追加された最新の二つのコミットはどのブランチにも属していないため、mainやkibidangoなどのほかのブランチにHEADを移すだけで履歴から消えてしまいます。

![](rsc/branch3.png){width=500}

これが、HEADは基本としてブランチに置くべき理由です。checkoutを使ってHEADをコミットに置いてしまうと、ブランチへの切り替えだけで簡単に履歴が消えてしまうのです。

非表示になってしまっても、あわてる必要はありません。GitGraphの右上にある歯車マークの「設定」を開き、「Include commits only mentioned by reflog」にチェックを入れてください。
![](rsc/branch_missed1a.png){width=500}

これで、非表示になっているものも含めてすべてこれまでのすべてのコミットが表示されます（下図右）。

![](rsc/branch_missed1.png){width=500}

:::

## ブランチに基づく開発

ここまで、ブランチを用いることで、複数の「作業環境」を目的ごとに作成、管理し、必要に応じてほかの作業環境へも変更内容を取り込めることを見てきました。しかし、実際のプロジェクトを進めるときには、具体的にはどのようにブランチを使用すればよいのでしょうか？

ブランチの利用には厳密なルールはありませんが、目安となる「ブランチ戦略」と呼ばれる運用手法がいくつか存在します。以下はその代表的なスタイルのひとつです。

---

最も基本的なルールでの運用は、安定版である「main」と、機能追加用である「feature/機能名」、バグ修正用の「fix/バグ名」の3種類のブランチに分ける方法です。

- 「main」ブランチは、安定して利用できる（＝バグがない、実際に計算に活用する）環境を維持する
- 原則として、「main」ブランチには直接コミットしない
- 新機能の開発は、まず「main」ブランチ上のコミットで、機能追加用ブランチ「feature/機能名」を作成する（例:feature/seasonal_dynamics）
- 機能の開発が完了して十分安定して利用できるレベルになれば、「feature/機能名」ブランチを「main」ブランチにマージする
- 「main」ブランチにバグが見つかって修正する場合は、「main」ブランチ上のコミットで、バグ修正ブランチ「fix/バグ名」を作成する（例:fix/fitness_calc_error）
- バグの修正が完了したら、「fix/バグ名」ブランチを「main」ブランチや、必要に応じて他の「feature/機能名」ブランチにマージする

つまり、ファイルの編集・バグ修正はすべてmainから枝分かれしたfeature・fixブランチ上で行い、mainブランチはマージによってのみ進むことになります。

---

より安定性を重視するケースでは、安定版の前に開発版「develop」を置くこともあります。この場合、運用ルールは以下のように変わります（変更点は太字）。

- 「main」ブランチは安定環境を維持する
- 原則として、「main」ブランチには直接コミットしない
- 新機能の開発は、まず**「develop」ブランチ上**のコミットで、機能追加用ブランチ「feature/機能名」を作成する
- 機能の開発が完了して十分安定して利用できるレベルになれば、「feature/機能名」ブランチを**「develop」ブランチ**にマージする
- **「develop」ブランチが十分安定したら、「main」ブランチにマージする**
- 「main」ブランチにバグが見つかって修正する場合は、「main」ブランチ上のコミットで、バグ修正ブランチ「fix/バグ名」を作成する
- バグの修正が完了したら、「fix/バグ名」ブランチを「main」ブランチや「develop」ブランチ、必要に応じて他の「feature/機能名」ブランチにマージする

このケースでは、「develop」ブランチが「main」ブランチへのマージの前に挟まることで、より「main」ブランチの安定性を高めることができます。

---

このようなルールを用いることで、ブランチごとの役割が明確になり、開発の流れや履歴が把握しやすくなります。

:::{.callout-note}
### 研究におけるブランチ戦略
ただし、上記はあくまで目安です。例えば、研究に用いるプログラムの場合は、個々の計算時のパラメータ設定等の編集に使うブランチである「analysis/計算目的」や、論文発表用にコードを整えるためのブランチ「release/論文名」などを作成してもよいかもしれません。
:::

gitにおいて、**ブランチは気軽に作成・削除するもの**です。重要なことは、mainブランチはあくまで安定版として残しておくことです。新しい改良を思いついたら、とりあえずfeatureブランチを切って試してみる、くらいの気軽さで使ってみましょう。上手くいけばマージすればいいし、仮に失敗してもそのまま放置しておけばよいのです。運が良ければ、後で気が向いてもう一度そのブランチを触ってみる気になるかもしれません。

```{=html}
<div class="prev-next-link">
    <a class="prev-link" href="commit.html">
        <p class="prev-next-label">prev</p>
        <p>コミットと変更履歴</p>
    </a>
    <a class="next-link" href="branch.html">
        <p class="prev-next-label">next</p>
        <p>サーバーとの同期</p>
    </a>
</div>
```