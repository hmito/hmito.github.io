---
title: ブランチ
format:
    html:
        toc: true
execute:
    eval: false
---
```{r}
#| echo: false
#| eval: false
print("a")
```

このページでは、複数のバージョンを同時に管理するために不可欠なgitの中心的概念の一つ、「ブランチ」について説明します。

## 今どこにいるか？：HEAD
gitでは「現在のフォルダの中身は変更履歴上のどのタイミングのものか」、つまり**現在のフォルダの状態のことをHEADと呼びます**。HEADの位置は、GitGraph上では「○」で表示され、コミットメッセージが太字になります。

![](rsc/branch0.png){width=500}

HEADの位置を変えることで、フォルダの中身を丸ごと過去の状態に戻すことができます。この操作をcheckoutと呼びます。HEADの位置を変えるには、GitGraph上の**適当なコミットメッセージの上で右クリックし、「Checkout」**を選びます。警告が出ると思いますが、無視して「Yes, checkout」を選んでください。

![](rsc/branch0a.png){width=500}

すると、HEADを示す「○」の位置、太字のコミットが切り替わったはずです。エクスプローラーからファイルを開くと、ファイルの中身がこのコミット時点の状態に戻っているのが確認できるはずです。このように、**HEADの位置を動かすことで、gitは任意の時点のフォルダを簡単に復元することができます**。試しに、いくつかのコミットをチェックアウトして、最新の状態から一番最初の状態まで、フォルダの中身を切り替えられることを確認してください。

## 履歴の枝分かれ：ブランチ
checkoutを使ってHEADを動かせばフォルダの中身を巻き戻すことはできますが、実は普段の操作では特定のコミットへのcheckoutはほとんど行うことはありません。これは、gitには**ブランチ**と呼ばれるより便利な仕組みがあるためです。

ブランチとは文字通り、履歴の「枝」の先端、変更履歴の「生長点」のようなものです。gitでは、新たなコミットはすべていずれかの**ブランチ**から行う必要があります。

GitGraphで見ると、最新のコミットに main と書かれたラベルがついています。これは、これまで伸ばしてきた変更履歴が、mainという名前のブランチから行われてきたことを示しています。

![](rsc/branch1.png){width=500}

ブランチを必要に応じて自由に作ることができます。**新しくブランチを作るには、GitGraph上で適当なコミットのメッセージ上で右クリックし、Create Branchを選択します**。ポップアップに適当な名前を入力して「create branch」を選ぶと、新たなブランチが作成されます。

![](rsc/branch1a.png){width=500}

現在のフォルダの状態**HEADは、GitGraph上でブランチのラベルをダブルクリック**することで切り替えることができます。HEADがあるブランチは、ブランチラベルが太字になります。画面下ステータスバーの左端にも現在HEADがあるブランチが表示されています。

![](rsc/branch2.png){width=500}

新たなコミットは、現在HEADがあるブランチに対して反映されます。例えば、先ほど作成した「kibidango」ブランチにHEADがある状態で新たな変更をコミットすると、kibidangoブランチが一つ進み、mainブランチと履歴が「枝分かれ」します。当然mainブランチへはこの新たなコミットは反映されません。

![](rsc/branch3.png){width=500}

このように、**ブランチはある種の「作業環境」として機能**します。ブランチを切り替える（ダブルクリックしてHEADを移動する）ことでフォルダの中身ごと切り替わり、その状態で行われたコミットは現在選択されているブランチに反映されます。「保存しておきたい作業環境」ごとにブランチを作成することで、ブランチごとの目的に集中して更新作業を行うことができます。

:::{.callout-tip}
### HEAD≠コミット上の位置
上でも少し触れましたが、HEADの位置は「コミット」の場合と「ブランチ」の場合、両方があります。

例えば、ブランチのラベルをダブルクリックせず、そのブランチがあるコミットをcheckoutすると、HEADはコミット上にある状態になります。この時、ブランチ名は太字にならず、ステータスバーにもブランチ名が表示されません（代わりにコミットIDと呼ばれる16進数が表示されています）。

![](rsc/branch2a.png){width=500}

これは、HEADが単にコミットの位置情報なのではなく、「今から行う変更はどのブランチに反映するか」を決めるものだからです。わかりやすいのは複数のブランチが同一のコミット上にある場合でしょうか。以下の例の場合、「kibidango」ブランチと「onitaiji」ブランチが両方同じコミット上にあり、この例では「onitaiji」ブランチ上にHEADがあることがわかります。この場合、新たなコミットは「onitaiji」ブランチに追加されます。

![](rsc/branch2b.png){width=500}

このように、ブランチの選択はコミットを置く先の選択という点でも重要です。

逆に、**HEADがブランチにない状態でもコミット自体は可能ですが、それらのコミットは少しの操作で消えてしまう不安定な状態**です。例えば、以下の例では最初のコミットにHEADを置いてから、いくつかのコミットを追加した状態です。

![](rsc/branch2c.png){width=500}

ところが、**これらのコミットはどのブランチにも属していないため、mainやkibidangoなどのほかのブランチにHEADを移すだけで履歴から消えてしまいます**。

![](rsc/branch3.png){width=500}

このように、HEADがブランチに置かれていない状態でのコミットは、あとで履歴が丸ごと消えてしまう危険性があるため、必ず通常はHEADはブランチに置きましょう。特定のコミットへのcheckoutは、せいぜい「一時的に過去のファイルの中身を確認するため」に使うくらいにとどめるべきです。

:::

## マージとチェリーピック

上述の通り、あるブランチにおけるコミットは、そのままでは他のブランチには反映されません。あるブランチにおける変更を別のブランチにも反映するには、二つの方法があります。

一つは、**チェリーピック cherry pick** と呼ばれる方法です。これは、**あるブランチにおける特定のコミットを現在のブランチに取り込む**操作です。

:::{.callout-note}
### cherry pick = つまみ食い
cherry pickとは、サクランボの熟したものだけを選んで食べる様から転じて、「つまみ食い」を意味する表現です。まさに、特定のコミットだけつまみ食いしているわけです。
:::

チェリーピックの操作は以下の通りです。

1. まず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）
2. 次に、取り込みたいコミットのメッセージなど、**ブランチタグ以外のエリアを右クリック**し、Cherry Pickを選択

![](rsc/cherrypick1.png)

3. cherry pick用の小さな画面が開くので、「Yes, cherry Pick」を選択

この操作で、取り込みたいコミットがコミットメッセージなども新たに現在のブランチに追加されたはずです。

![](rsc/cherrypick2.png)

:::{.callout-note}
エラーメッセージが表示された場合は、次の[コンフリクト](#マージの中止)を確認してみてください。
:::

--------

もう一つは、**マージ merge** と呼ばれる方法です。これは、**あるブランチが現在のブランチと分岐後に行われた全てのコミットを現在のブランチに取り込む**操作です。つまり、二つのブランチの分岐点からの変更がすべて取り込まれます。

マージの操作は以下の通りです。

1. まず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）
2. 次に、取り込みたい**ブランチタグを右クリック**し、「Merge into current branch」を選択

![](rsc/merge1.png){width=500}

3. Merge用の小さな画面が開く。上部に「... merge branch マージされるブランチ into 現在のブランチ」と表示されていることを確認して、「Yes, merge」を選択

![](rsc/merge2.png){width=500}

この操作で、自動的に「Merge branch ...」というメッセージを持つ**マージコミット**と呼ばれるコミットが作成されます。マージコミットの左側では、マージされた側のブランチからマージしたブランチへと合流するラインがひかれます。マージコミットの中身を確認すると、マージされる側において分岐後に行われた全てのコミット（下の例では「黍団子のレシピの追加」と「おじいいさんおばあさんの黍団子の描写を追加」の二つのコミット）の内容が含まれているはずです。

![](rsc/merge3.png){width=500}

:::{.callout-note}
エラーメッセージが表示された場合は、次の[コンフリクト](#マージの中止)を確認してみてください。
:::

このように、マージは特定のブランチにおける変更を丸ごと取り込むために使用されます。マージされたあとのブランチには、それまでに両方のブランチで行われた変更すべてが含まれており、文字通り二つのブランチを「合併」したものとなります。

## 編集の競合：コンフリクト

### 同一箇所への編集によるコンフリクト

チェリーピックやマージは、二つの異なるブランチ間で行われた変更を統合する作業です。それでは、もし二つのブランチが同一のファイルを編集していた場合、どうなるでしょう？　この場合でも、変更が異なる箇所（例えばファイルの先頭と末尾）に行われている場合には、両方の変更がうまく残されます。しかし、もし**同一の箇所が変更されていたり、ファイル自体が削除されている場合では、編集の競合：コンフリクトが発生します。

コンフリクトが発生すると、以下のようなエラーメッセージが表示されます。

![](rsc/merge_conflict1.png){width=200}

「Dismiss」（却下）を選ぶと、マージコミットは作成されておらずマージ前に戻っているように見えますが、ソース管理画面ではすでにコミットメッセージが入力されており、その下部には「変更のマージ」というファイルがステージ済みのファイルなどとともに表示されているはずです。ここに記載されているファイルが、コンフリクトが発生したファイルです。クリックすると、コンフリクトの詳細を確認できます。

![](rsc/merge_conflict2.png){width=500}

コンフリクトの解決は簡単です。まず、コンフリクトが発生したファイルをクリックした際に右下に表示される「マージエディターで解決」を選択します。すると、「マージ：ファイル名」というタブが新たに開きます。

![](rsc/merge_conflict3.png){width=500}

この画面では、上部の左側にマージされる側のブランチ、右側に現在のブランチのファイルの状態が示されています。スクロールバーでは、コンフリクトが発生した位置が黄色く表示されています（上の例では3か所）。画面下部では、コンフリクトを解決した後のファイルが表示されます。解決は、以下のいずれかの方法をとります。

- どちらかの変更を反映したい場合、反映したい側で「（現在のマシン/受信中）を適用する」ボタンを押す
- 両方の変更を残したければ、両側で押すか、「組み合わせを宇井家入れる」を選ぶ
- どちらの変更も反映したくなければ、「無視する」を両側で選ぶ
- 画面下部で手動で編集して解決することもできる

解決済みになると、スクロールバー上の表示が黄色から灰色に変わります。全てのコンフリクトを解決後、画面右下の「マージを完了」を押します。これで、当該ファイルは「変更のマージ」から「ステージされている変更」に移動します。

他にもコンフリクトが発生しているファイルがあれば、同様の手順で解決します。すべてのファイルが「ステージされている変更」に移動したら、続行ボタンを押します。これで無事マージは終了です。

![](rsc/merge_conflict4.png){width=500}

### ファイルの削除に伴うコンフリクト

一方ではファイルが削除、または移動されてしまっていることによるコンフリクトが起きることもあります。この場合、ソース管理画面で「変更のマージ」にあるファイルを選んでも、「マージエディターで解決」ボタンは表示されません。

この場合は、ファイルを右クリックし「変更をステージ」を選んでください。ファイルを削除するか残すかを選択できます。

### マージの中止

コンフリクトが発生した場合、マージ自体を中止したいかもしれません。この場合、以下の手順でマージを中止できます。

1. GitGraphの上部右端にあるRefreshボタンを押す
2. 「Uncommitted Changes」という表示が履歴の最上部に現れるので、右クリックし「Reset Uncommitted Changes」を選ぶ
3. Resetの確認画面が表示されるので、「Mixed」ではなく「Hard」を選び、「Yes, reset」を選択する

![](rsc/merge_conflict5.png){width=500}

以上の手順で、マージ前の状態に戻すことができます。

## ブランチに基づく開発

「ブランチを切る）


ブランチを用いることで、複数のバージョン管理ができることは分かったかと思います。しかし、そもそもブランチはどのような場合に利用するのでしょうか。

多くのプロジェクトでは、試行錯誤を繰り返す「開発」の段階と、実際に使用する「運用」の段階がしばしばあります。しかし、このような異なる段階におけるコミットが一本の履歴上にあると以下のような問題が起きます。

- 複数の目的の変更を同時進行で進めると、それぞれ異なる目的の変更が混ざってしまう
- 「いつどんな目的でこれらの変更が行われているのか」が変更履歴からわかりにくくなる
- ある機能に関する変更が、ほかの機能にも影響を与えてしまい、運用したいのに動かなくなってしまう

この問題を解決するために考え出されたのが、ブランチを用いた開発手法です。gitでは、
基本的に新しいアイデアを試す際には、それ専用のブランチを作ります。

```{=html}
<div class="prev-next-link">
    <a class="prev-link" href="commit.html">
        <p class="prev-next-label">prev</p>
        <p>コミットと変更履歴</p>
    </a>
    <a class="next-link" href="branch.html">
        <p class="prev-next-label">next</p>
        <p>サーバーとの同期</p>
    </a>
</div>
```