---
title: コミットと変更履歴
format:
    html:
        toc: true
execute:
    eval: false
---

```{r}
#| echo: false
#| eval: false
"https://bonjin-ultra.com/take1.htm"
```

まずは、gitの基本的な操作である「変更履歴の記録」と「過去の履歴の確認」の操作について見ていきましょう。

## リポジトリの初期化
gitにおけるバージョン管理の単位はフォルダです。任意のフォルダを指定すると、そのフォルダ内の全てのファイルについてバージョン管理を行います。この**バージョン管理の単位を「リポジトリ」と呼びます**。通常は、プログラムごと、あるいはプロジェクトごとに一つのリポジトリを作ることが多いでしょう（裏を返すと、一つのプロジェクトに関連するファイルは全て一つのフォルダ内に収めることを想定している、とも言えます）。

**gitで新たなフォルダのバージョン管理を始めるには、そのフォルダにおいて「リポジトリの初期化」処理が必要**です。この操作は、新しいフォルダをバージョン管理の対象にするたびに一度だけ実行する処理です。フォルダは空でも構いませんし、すでにいくつかのファイルがあってもかまいません。

VSCodeでは、gitに関連した操作は左メニューにある、丸三つが線でつながれたマークの「ソース管理」アイコンから行います。操作は以下の通りです。

1. まず、VSCodeを使ってバージョン管理の対象とする[フォルダを開く](../vscode.qmd)。
1. 左メニューから「ソース管理」（丸三つが線でつながれたボタン）を開きます。
1. ソース管理画面に表示されている「リポジトリを初期化する」ボタンを押すと、表示が「コミット」と切り替わります。これで初期化完了です。
    - [VSCodeの設定](setup.qmd/#vscodeの設定)を行っていない場合「Branchの発行」と表示されますが、無視してかまいません。

![](rsc/repoinit.png)

## ファイルの変更
リポジトリの初期化が済めば、あとは好きにそのフォルダ内のファイルを編集して構いません。**gitはフォルダ内を監視し、変更があれば自動的に検出**します。前回の状態からの「差分」を監視しているので、VSCodeを使わずに変更した内容でも問題なく検出してくれます。

試しにいくつかのファイルを編集し、保存してみてください。**変更されたファイルがある場合、ソース管理ボタン上に青いバッジで表示**されるはずです。バッジ中の数字は、変更されたファイルの数を表しています。ソース管理の画面を開くと、変更されたファイルの一覧が表示されているはずです。

![](rsc/commit1.png)

:::{.callout-note}
### 未保存に注意！
保存されていない状態だとソース管理には表示されませんので、必ず保存できているか確認してください（ファイルタブの右端が通常の閉じるボタン×ではなく●となっていると未保存です）。

![](rsc/vscode_unsaved.png)

未保存のファイルがあると、左メニューのエクスプローラボタンの上に未保存のファイル数が青いバッジで表示されます。
:::

クリックすると「ファイル名（作業ツリー）」という名前の新たなタブが開きます。このタブでは、変更内容が赤（削除）と緑（追加）で表示されています。右端には、ファイル全体の変更位置についてスクロールバーに重ねて同じく赤と緑で表示されています。

![](rsc/commit2.png)

ファイル自体の追加・削除も変更の一種として扱われます。ソース管理画面では、ファイルの横につくアルファベットで「U:新規ファイル(Untracked)」「M:変更されたファイル(Modified)」「D:削除済ファイル(Deleted)」を区別することができます。

![](rsc/commit2a.png)

## 履歴の記録：ステージとコミット
ファイルの編集が一通り済んだタイミングで、変更履歴を手動で記録する必要があります。この**履歴の記録は「ステージ」と「コミット」、二つの操作によって成り立っています**。

:::{.callout-note}
### 自動で履歴が記録されないのは？
自動で履歴が記録されないのは一見不便に思うかもしれませんが、これは編集中などの中途半端なタイミングで多数の履歴が残り、結果として後でどの履歴を確認すればよいか分からなくなるのを避けるためにこうした仕組みになっています。
:::

### ステージ
**「ステージ」は記録する変更内容を選択する操作です**。ソース管理画面には編集した全てのファイルが表示されますが、これら全ての変更を一度に記録する必要はなく、どの変更を記録するかまず選ぶわけです。

- **ステージする**には、「変更」にあるファイルに**オンマウスした際に右側に表示される「＋」マークをクリック**、または右クリックで表示される「変更をステージ」を選択します。これで、「ステージされている変更」にファイルが移動します。

![](rsc/commit3.png)

- **ステージを取り消す場合**は、「ステージされている変更」にあるファイルに**オンマウスした際に右側に表示される「ー」マークをクリック**、または右クリックで表示される「変更のステージング解除」を選択します。これで、「変更」にファイルが戻ります。

![](rsc/commit4.png)

- 全ファイルの変更をステージしたければ、「変更」の行自体にオンマウスした際に右側に表示される「＋」マークをクリック、または右クリックで表示される「すべての変更をステージ」を選択します。
- ファイル丸ごとではなく、各ファイルの内部の変更毎にステージすることもできます。ファイルをクリックして「ファイル名（作業ツリー）」タブを開き、変更したい行を選択後左側に表示される「＋」マークをクリックします。

![](rsc/commit5.png)

### コミット
記録したい内容をステージできたら、次に **「コミット」でgitに変更履歴として記録**します。この際、簡単な変更内容についてのメモをコミットボタンの上にある「メッセージ」欄に入力します。端的に何を変えたのかが後から振り返ってわかる記述が良いでしょう。

- **メッセージを入力し「コミット」ボタンを押す**ことで、その時ステージされている変更履歴が記録されます。

![](rsc/commit6.png)

gitの普段の操作は、この「ステージ」と「コミット」の繰り返しです。ある程度まとまった変更を行ったら、キリが良いタイミングでコミットをする習慣をつけるのが、gitの利用の第一歩です。

## 履歴を見る
過去にコミットした変更履歴は、いつでも確認することができます。VSCodeの標準機能は機能として不十分なため、ここでは拡張機能としてインストールした**Git Graph**を利用します。

ソース管理画面の上部にある三つの点が複数の曲線でつながれた「Git Graph」ボタンを押すか、画面下部ステータスバーの左側にある「Git Graph」の文字を押すことで、「GitGraph画面」を開くことができます。

![](rsc/history1.png)

GitGraph画面では、下から上へとコミット操作によって保存された変更履歴が表示されています。**各履歴をクリック**することで、そのコミットによってどのファイルが変更されたか表示されます。さらに、**履歴の中のファイルをクリック**することで、そのファイルの変更内容自体も表示されます。

![](rsc/history2.png)

ある履歴をクリックした後、**別の履歴をCtrlキーを押しながらクリック**することで、複数の履歴の間に行われた全変更を調べることもできます。

ファイルごとの履歴も、同じく拡張機能としてインストールした**Git History**で調べることができます。ファイルを開いていると右上に表示される「時計」マークをクリック、またはファイル名を右クリックして表示される「Git: View File History」を選択することで、そのファイルが変更されたコミット一覧が表示されます。コミットを選択後、「Previous」ボタンを押すと、どのように変更されたかが表示されます。

![](rsc/history3.png)

## 変更の破棄と取消
ファイルを変更してみたものの納得がいかない場合、元に戻すことができます。状態に合わせて、いくつかの方法があります。

### コミット前の変更を破棄したい
コミットする前の状態であれば、ソース管理画面でステージボタン「＋」の横にある**変更を破棄ボタン「↶」を押すと、そのファイルの変更すべてが打ち消されます**。ステージの場合と同様、ファイルの中の特定の部分だけ選択して変更を破棄することもできます。

![](rsc/revert1.png)

### コミット後、特定のコミットの内容を取り消したい
**すでにコミットした変更を取り消したい場合、Revert**を使います。GitGraphを開き、打ち消したいコミットメッセージの上（mainと書かれたマークの上だとうまくいきません）で右クリックをし、「Revert」を選びます。確認画面が出ますので、「Yes, revert」を選んでください。

![](rsc/revert2.png)

すると、「Revert "..."」というメッセージの新たなコミットが自動的に追加されます。この追加されたコミットはRevertしたコミットの逆、つまり「追加された内容は削除し、削除された内容は追加する」ような**Revertしたいコミットの変更を打ち消すための変更**が行われています。

![](rsc/revert3.png)

:::{.callout-note}
### 取消なのに新しいコミットが追加される？
取り消そうとしたのに新しいコミットがさらに追加される、というのは不思議に思うかもしれませんが、これは「取り消し自体も一つの変更として履歴に記録するべき」というGitの考え方を反映した動作です。

:::

なお、注意点として、**Revertは特定のコミットの打ち消し操作であり、特定の時点まで戻す操作ではありません**。例えば、3つ前のコミットをRevertした場合、取り消される変更はそのコミットの変更のみで、1つ前、2つ前のコミットの変更は反映されたままです。3つ前の段階まで戻すには、1つ前、2つ前のコミットもRevertする必要があります。

なお、リポジトリの状態をあるコミットの時点まで戻す方法は、ほかにもいくつかあります（checkout、reset）。これらの方法はブランチの概念を学ぶ必要があるため、次ページ以降で触れます。

:::{.callout-note}
### 良いコミットの区切り方
ここまでコミットは「ファイルの編集が一通り済んだタイミングで行う」としか説明してきませんでした。実際はどの程度まで編集したときにコミットすればよいのでしょう？

この答えは状況にもよりますが、上で触れた「コミットの打ち消し」Revert操作が一つの目安になります。

もし一つのコミットにあまりに多くの変更が含まれていると、Revertした際に本来は戻したくない変更まで取り消されてしまいます。一方で、あまりに一つ一つのコミットが細切れだと、あとから取り消そうと思ったときにいくつものコミットをRevertする必要が出てくるかもしれません。

「この変更は単独でRevertできるか？」を自問しながらコミットを作ると、適切なコミットの頻度が見えてくるでしょう。
:::

```{=html}
<div class="prev-next-link">
    <a class="prev-link" href="setup.html">
        <p class="prev-next-label">prev</p>
        <p>環境構築</p>
    </a>
    <a class="next-link" href="branch.html">
        <p class="prev-next-label">next</p>
        <p>ブランチ</p>
    </a>
</div>
```
