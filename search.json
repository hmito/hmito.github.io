[
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "研究紹介",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "learning/vscode.html",
    "href": "learning/vscode.html",
    "title": "VSCodeの使い方",
    "section": "",
    "text": "Visual Studio Code (以下VSCode)は、エディタ（ソースコードを書くためのソフト）の一種です。以下のような特徴を持つことから、現在幅広く使われています。\n\nWindows、macOS、Linuxなど、環境を問わず無料で利用可能\ntxtはもちろん、R、Python、C++、md、htmlなどほとんどの言語・ファイル形式に対応\nプログラムの記述、実行、デバッグ、ソースコード管理なまで、一通りの機能がそろっている\n拡張機能をはじめ、カスタマイズ性が高い\n軽量で、動作が非常に高速\n\nこのページでは、Visual Studio Codeのインストールから簡単な使い方まで、一通り解説します。"
  },
  {
    "objectID": "learning/vscode.html#vscodeとは",
    "href": "learning/vscode.html#vscodeとは",
    "title": "VSCodeの使い方",
    "section": "",
    "text": "Visual Studio Code (以下VSCode)は、エディタ（ソースコードを書くためのソフト）の一種です。以下のような特徴を持つことから、現在幅広く使われています。\n\nWindows、macOS、Linuxなど、環境を問わず無料で利用可能\ntxtはもちろん、R、Python、C++、md、htmlなどほとんどの言語・ファイル形式に対応\nプログラムの記述、実行、デバッグ、ソースコード管理なまで、一通りの機能がそろっている\n拡張機能をはじめ、カスタマイズ性が高い\n軽量で、動作が非常に高速\n\nこのページでは、Visual Studio Codeのインストールから簡単な使い方まで、一通り解説します。"
  },
  {
    "objectID": "learning/vscode.html#インストール",
    "href": "learning/vscode.html#インストール",
    "title": "VSCodeの使い方",
    "section": "インストール",
    "text": "インストール\n公式Webサイトからインストーラーをダウンロードしてきてもよいですが、以下のようなwinget（Windows）あるいはbrew（macOS）を使ったインストールが簡単です。\n\nWindowsの場合Macの場合\n\n\nスタートメニューでPower Shellと検索し、出てきたアプリを実行してください。開いた画面で、以下のコマンドを入力し、最後にエンターキーをおしてください。\n\nwinget install Microsoft.VisualStudioCode\n\n\n\n\nhomebrewをインストール後、ターミナルで以下のコマンドを入力し、最後にエンターキーをおしてください。\n\nbrew install --cask visual-studio-code\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n上手くいかなければ、以下のWebサイトからもインストール可能です。 https://code.visualstudio.com\n\n\n上手くインスト―スできれいれば、Power Shell、またはターミナル上で以下のコマンドを入力し、最後にエンターキーを押すことで、VSCodeが立ち上がるはずです。\n\ncode\n\n\nもちろん、スタートメニュー（Windows）やアプリ一覧から開いてもかまいません。"
  },
  {
    "objectID": "learning/vscode.html#日本語化",
    "href": "learning/vscode.html#日本語化",
    "title": "VSCodeの使い方",
    "section": "日本語化",
    "text": "日本語化\nデフォルトでは英語表示なので、日本語化しましょう。左側のメニューから拡張機能ボタン（4つの四角マーク）を選びます。検索窓でJapaneseを検索し、出てきた一番上のJapanese Language Pack for Visual Studio Codeのinstallボタンをクリックします。\n\nすると、右下に言語設定を変えて再起動するか尋ねてくるポップアップが出るので、青いボタンを押します。 \nこれで、表示が日本語に切り替わったはずです。\n\n\n\n\n\n\nNote\n\n\n\n上記でうまく日本語化できない場合、Japanese Language Pack for Visual Studio Codeのインストール後、VSCode上部の検索窓に 「&gt; display」と入力し、出てきた候補から「Configure Display Language」を選択し、日本語を選んでみてください。"
  },
  {
    "objectID": "learning/vscode.html#使用方法",
    "href": "learning/vscode.html#使用方法",
    "title": "VSCodeの使い方",
    "section": "使用方法",
    "text": "使用方法\n\nファイルの表示\nVSCodeは、通常フォルダ（ディレクトリ）を単位として開きます。これは、プログラミングでは複数のファイルを同時に扱うことが多いためです。\n上部メニューの「ファイル」から「フォルダーを開く」を選択し、目的のフォルダを選択することでそのフォルダを開くことができます。\n\n\n\n\n\n\n\nNote\n\n\n\n初めて開くフォルダでは、以下の画像のような警告画面が表示されることがあります。自分で作成したフォルダや、信頼できる場所からダウンロードしたファイルの場合は、気にせず「はい、作成者を信頼します」を選んでください。「いいえ」を選んだ場合、プログラムの実行等が制限されます。\nなお、「はい」の上部にある「親フォルダ・・・内のすべてのファイルの作成者を信頼します」にチェックを入れると、以後その親フォルダ内（つまり開いたフォルダの一つ上の階層のフォルダ内）にあるファイル・フォルダを開く場合は警告が表示されなくなります。\n\n\n\nここでは、「古典集」というサンプルフォルダを開いてみます。このサンプルを試してみたい場合は、以下からzipファイルをダウンロード後、中にある「古典集」というフォルダを適当な場所においてから開いてみて下さい。\n【古典集（サンプルフォルダ）をダウンロード】\n画面全体の構成は以下のようになっています。\n\n\nメニューバー：フォルダを開いたり、表示設定、細かい編集操作に使用。画面幅が狭いと省略され「≡」と単一ボタンとなっていることもある。\nアクティビティバー：主要なツールへのアイコンを表示。\nサイドバー：アクティビティバーで選択しているツールの内容を表示。\nメイン画面：開いたファイル等はここにタブ形式で表示。\nステータスバー：ファイルについての情報等を表示\n\nアクティビティバーの一番上、ファイルマークのアイコンが、「エクスプローラ」ツールです。このツールは、サイドバーに開いたフォルダ内にあるファイル・フォルダ一覧を表示します。サイドバー上部には、現在開いているフォルダ名（この例では「古典集」）が表示されます。\n\nファイルをクリックすると、メイン画面にそのファイルが開きます。ワンクリックだと\n\nこれらのファイル・フォルダの配置は、実際のフォルダ内の階層構造と一致しています。\n\nこの画面からは、おおよそのファイル操作を行うことができます。 - ファイル名をクリック&ドラッグで移動させると、ファイルの位置も移動します- 名前の変更・ファイルの削除も、ファイルを右クリックしたメニューから行えます\n\n\n\n\n\n\n\n\n\n\n\n\n名付けたフォルダを新たに作成し、開いてみます。Windowsの場合、右クリックから「新規作成」→「フォルダ」の順で選び、作成したフォルダを選択した状態で「フォルダを選択」を押します。\n\n\n\n\n\n\n\n\n\n\n\n上手くいけば、左サイドバーに KOTEN とフォルダ名が書かれているはずです。"
  },
  {
    "objectID": "learning/vscode.html#ファイルを比較する",
    "href": "learning/vscode.html#ファイルを比較する",
    "title": "VSCodeの使い方",
    "section": "ファイルを比較する",
    "text": "ファイルを比較する"
  },
  {
    "objectID": "learning/vscode.html#検索置換",
    "href": "learning/vscode.html#検索置換",
    "title": "VSCodeの使い方",
    "section": "検索、置換",
    "text": "検索、置換"
  },
  {
    "objectID": "learning/vscode.html#おすすめの設定",
    "href": "learning/vscode.html#おすすめの設定",
    "title": "VSCodeの使い方",
    "section": "おすすめの設定",
    "text": "おすすめの設定\n最後に、使いやすくするための細かい表示設定を紹介します。これらの設定は好みの問題なので、必ずしも設定する必要はありません。実際に使ってみながら、検討してみてください。\nミニマップ"
  },
  {
    "objectID": "learning/git/useful.html",
    "href": "learning/git/useful.html",
    "title": "便利な機能",
    "section": "",
    "text": "このページでは、ここまで取りこぼしてきたgitの便利な機能を見ていきます。"
  },
  {
    "objectID": "learning/git/useful.html#コミット前の変更の一時退避スタッシュ-stash",
    "href": "learning/git/useful.html#コミット前の変更の一時退避スタッシュ-stash",
    "title": "便利な機能",
    "section": "コミット前の変更の一時退避：スタッシュ stash",
    "text": "コミット前の変更の一時退避：スタッシュ stash\nブランチの切り替える際には、ファイルの変更ない（＝すべての変更がコミット済）である必要があります。しかし、以下のようにコミット前にブランチを切り替えたい場合もしばしば存在します。\n\nコミット前に、他のブランチにおけるファイルの状態の確認したい\nファイルを変更し始めたが、ブランチの選択が間違っていることに気づいた\n\nこの場合、スタッシュ stashと呼ばれる操作で、一時的に変更内容を保存・退避する「一時的なコミット」のようなものを作ることができます。操作は以下の通りです。\n\nコミット前の変更があると、GitGraph上では「Uncommitted Changes」と表示されるので、その部分を右クリックし、「Stash uncommitted changes」を選択\n\n\n\nポップアップが出るので、適当なコミットメッセージに類するメッセージを書き、「Yes, stash」を選択\nこれで、stashと書かれたラベルが新たに作成され、ファイルは変更前の状態に戻る。ブランチの切り替えなどをしてもstashは消えない\n\n\n\nブランチの切り替えなどの作業が済めば、stashラベルを右クリックし、「Pop stash」を選択することで、元の「ファイルを変更したがコミットしていない」状態に戻せる\n\n元のブランチ以外を選択した状態でもpopできる。よって、あるブランチで行ったコミット前の変更を、別のブランチに移動することができる\n\nstashが不要であれば、「Drop stash」で削除できる\n\n\n注意点として、stashはローカル専用です。リモートには反映されないので、他のPCへstashの内容を送ることはできません。"
  },
  {
    "objectID": "learning/git/useful.html#ブランチの巻き戻しリセット-reset",
    "href": "learning/git/useful.html#ブランチの巻き戻しリセット-reset",
    "title": "便利な機能",
    "section": "ブランチの巻き戻し：リセット reset",
    "text": "ブランチの巻き戻し：リセット reset\nすでにコミット済みの変更を取り消す方法として、リバート revertがありました。リバートは取消自体もコミットとして残る安全な方法ですが、以下のような場合、コミットしたこと自体も取り消したいかもしれません。\n\n複数のコミットに分散してしまったが、まとめてコミットしたい\n色々と変更しつつ進めたが、誤りに気付いたのでそれらのコミットごとなかったことにしたい\n間違ったブランチを進めてしまった\n\nこのようなコミットした履歴自体の改ざんする方法としてリセット resetがあります。リセットの操作方法は以下の通りです。なお、履歴自体をないことにしてしまう操作であり、非常に危険である点に注意してください。\n\n履歴を改ざんしたいブランチにHEADを移動（ブランチラベルをダブルクリック）\n戻りたい時点のコミットを右クリックし、「Reset current branch into this Commit」を選択\n\n\n\nポップアップが出るので目的に応じて設定し、「Yes, reset」を選択\n\nフォルダの状態まで元に戻したくない場合は、「Mixed」を選択\nフォルダの状態も含めて戻したい場合は、「Hard」を選択\n\n\nこれで、ブランチラベルが当該コミットまで戻ります。「Mixed」を選んだ場合、ソース管理画面に、ファイルの変更内容がコミット前の状態で残されているはずです。\n\n\n\n\n\n\nリモートの操作は危険\n\n\n\nリモートの環境は完全に他者と共有しています。このため複数人での共同作業時に、以下のような操作をリモート環境に反映するのは大変危険ですので絶対にやめましょう。\n\nブランチを改名した\nブランチを削除し、別の場所に新たに同名のブランチを作成した\nブランチをリセットして巻き戻した\n\nこれらの操作を行った場合、もし他の人がそれらのブランチをローカルに持っていた場合、履歴がつながらない形でリモートブランチが「ワープ」したことになり、大量のコンフリクトが発生し、最悪の場合進行中の作業が失われるなど深刻な結果を招きます。\nresetを利用した履歴の改変は、あくまでpush前、ローカル環境だけでの操作にとどめましょう。\n\n\n\n\n\n\n\n\n履歴に残したブランチの巻き戻し方\n\n\n\n危険を承知でどうしてもブランチの中身を巻き戻したい場合、「履歴を改変せず、コミットの形で変更を打ち消す」ことが重要です。つまりブランチ自体の位置を戻そうとするのではなく、ブランチを進めつつ中身を戻す、という方法です。\nこのための方法の一つ目は、コミットと変更履歴のページで触れたrevertです。これは特定のコミットを打ち消す新たなコミットを作成するため、比較的安全な方法です。戻りたい時点まで順に遡りながらrevertすればフォルダの状態を戻すことができます。しかし、この方法はコミットが複数にまたがっている場合でも一つ一つに対して操作が必要となります。\nそこで、もう一つの方法が リセット reset を活用した方法です。revertを活用するよりは危険性は高いですが、任意のコミットの時点までフォルダの状態を戻すことができます。もっとも、リセットの使用自体がリスクが高いので、十分注意して実行して下さい。\n\n戻したいブランチがリモートブランチと同期されていることを確認する\n\nこの条件が満たされていないと、resetと同時に変更履歴が消えてしまいます\n\n戻りたいコミットまでhardでリセットをかける\n\nこれで、ローカルブランチのラベルがこのコミットに移動するはずです\nこの操作で、ファイル状態は戻りたいコミットの状態まで戻ります\n\n再びリモートブランチのあるコミットまで、mixedでリセットをかける\n\n再びローカルブランチのラベルがリモートブランチのラベルと一致した「同期状態」として表示されます\nただし、mixedリセットなのでフォルダの状態は巻き戻らず、上記コミットの状態のままとなります\n\nコミットされていないファイルの変更（Uncommitted changes）が表示されているはずなので、全てステージしコミットする。コミットメッセージには、特定のコミットまでロールバックした旨を記載しておく。\n\nこれで、ブランチの状態は進めつつ、特定のコミットの時点までフォルダの状態を巻き戻すことができた（一つのコミットでこれまでの変更をすべて打ち消すことができた）はずです。必要に応じてプッシュでリモートのブランチに反映してください。"
  },
  {
    "objectID": "learning/git/useful.html#コミットにラベルを付けるtag",
    "href": "learning/git/useful.html#コミットにラベルを付けるtag",
    "title": "便利な機能",
    "section": "コミットにラベルを付ける：tag",
    "text": "コミットにラベルを付ける：tag\n作業環境ではなく特定の「バージョン」のようなものを管理する場合、ブランチのようにコミットに従って移動していくのではなく、特定のコミットに紐付けて残しておきたいでしょう。\nこのような、特定のコミットにつけるラベルをタグ tagといいます。作成は以下の通りです。\n\nタグをつけたいコミットで右クリックし、「Add tag」を選択\nポップアップにタグの名前を入力し、「Add Tag」を選択\nタグが履歴上に作成・表示される\nタグを削除する際は右クリックから「Delete tag」を、リモートにもプッシュしたい場合は「Push tag」を選ぶ\n\nタグ作成時のポップアップで「push remote」にチェックを入れておけば、作成と同時にリモートリポジトリにも自動でプッシュされる\n\n\nなお、手順にもある通り、タグはそのままではローカルでしか見えないため、リモートにも反映するためにはpushの作業が必要です。\n\n\n\n\n\n\nタグの便利な機能\n\n\n\nタグの便利な使い方を二つ紹介します。\n一つ目は、特定のバージョンのファイルの配布です。多くのホスティングサービスでは、特定のタグが付いたバージョンのファイルを表示させることができます。Githubでは以下の通りです。\n\nGitHubにログインし、リポジトリを開く。\n「Code」タブからブランチ名をクリックし、「タグ」のタブを開いて求めるバージョンをクリック\n\n\n\nこれで特定のタグが付いたコミットのファイルが表示される。右上の「&lt;&gt; Code」ボタンからZipをダウロードすることもできる。\n\n左クリックせず、右クリックすることでZipダウンロード用のURLも取得できる\n\n\n\n二つ目は、研究の際の計算の管理です。シミュレーション等では、しばしばパラメータを変えながら大規模な計算を実施することがありますが、このような計算を「どのバージョンで行ったか」を記録しておくことは、あとで同じ結果を再現するためにも、バグが見つかった時に影響がないかを確認するためにも非常に重要です。\nそこで、大規模な計算を実施するごとにその計算に名前を付けておき、同名のタグをgit上でつけておきます。計算結果を入れるフォルダ名にも同じ名前を付ければ、あとから計算結果を見た際に「この結果はどのバージョンで計算したものか」を簡単に紐付けることができます。"
  },
  {
    "objectID": "learning/git/useful.html#不要なファイルを無視するignore",
    "href": "learning/git/useful.html#不要なファイルを無視するignore",
    "title": "便利な機能",
    "section": "不要なファイルを無視する：ignore",
    "text": "不要なファイルを無視する：ignore\ngitは特定のフォルダの中身を丸ごとリポジトリとして管理します。しかし、以下のようなファイルは管理対象とするのは避けるべきものです。\n\nコンパイル時の一時ファイルやログファイルのように、そもそも不要なファイル\nVScodeの設定ファイルや、計算アプリRが出力するデータ「.RData」ファイルのように、そのPCで動作するには必要だが、他のPCには不必要なファイル\n画像やバイナリファイルのように、Gitが同期するのが苦手な文字形式でない大量のファイル\n.DS_StoreやThumbs.dbなど、OSが作成する隠しファイル\n\nこれらのファイルを、gitで管理してしまうと不要なファイルが同期されてしまいます。\nそこで、指定のファイルを同期から除外する機能、ignoreがあります。ignoreの設定方法は以下の通りです。\n\n「ソース管理」画面の変更欄で、無視したいファイルを右クリックし、「.gitignoreに追加」を選択\n\n\n\n「.gitignore」という名称のファイルが変更されるので、通常の変更同様、ステージしてコミット\n\n.gitignoreの中身を見てみると、先ほどの無視したファイルのパスが書かれたただのテキストファイルであることがわかります。\n\n実は、無視するファイル類はこのファイルを直接テキストで編集するだけでも、登録することができます。以下のような特殊な表記を使うことで、より柔軟な指定が可能です。\n# 「#」で始まる行は無視される\n\n# 「/」で終わると、そのフォルダ内、という意味になる\n# 「png」フォルダの中身を無視する\npng/\n\n# 「*」はワイルドカードと呼ばれる「なんでも当てはまる部分」になる\n# 拡張子が「.dat」で終わるファイルをすべて無視する\n*.dat\n\n\n\n\n\n\n計算結果の管理\n\n\n\n研究では、大規模計算の結果をしばしば出力しますが、これらのデータはたいていgitが保存することが苦手なデータです。\nそこで、計算結果は丸ごとどこかのフォルダ（例えば「analysis」や「data」など）に出力し、そのフォルダの中身は丸ごと.gitignoreに登録してしまうと、便利です。これらのフォルダの中に、サブフォルダとして上で触れた「タグにする計算名」にしておけば、より管理が簡単かもしれません。\nなお、.gitignoreに登録したデータは当然バックアップされないので、他の手段（オンラインストレージなど）でバックアップ・同期を取るようにしておくと良いでしょう。\n\n\n\n    \n        prev\n        サーバーとの同期\n    \n    \n        up\n        git入門"
  },
  {
    "objectID": "learning/git/setup.html",
    "href": "learning/git/setup.html",
    "title": "環境構築",
    "section": "",
    "text": "このページではgitを使うための環境を準備していきます。Gitアプリ、VSCode、そしてVSCodeを使いやすくするために、いくつかの拡張機能の導入や設定変更を行います。"
  },
  {
    "objectID": "learning/git/setup.html#gitアプリとgitクライアントの用意",
    "href": "learning/git/setup.html#gitアプリとgitクライアントの用意",
    "title": "環境構築",
    "section": "Gitアプリとgitクライアントの用意",
    "text": "Gitアプリとgitクライアントの用意\ngitを操作するためには、Gitアプリが必要となります。公式Webサイトからインストーラーをダウンロードしてきてもよいですが、以下のようなwinget（Windows）あるいはbrew（macOS）を使ったインストールが簡単です。\n\nWindowsの場合Macの場合\n\n\n\nスタートメニューでPower Shellと検索し、出てきたアプリを実行\n開いた画面で以下のコマンドを入力し、最後にエンターキーを押す\n\n\nwinget install Git.Git\n\n\n\n\nhomebrewが未導入なら、まずリンク先からインストール\nターミナルで以下のコマンドを入力し、最後にエンターキーを押す\n\n\nbrew install git\n\n\n\n\n\n\n\n\n\n\nWebサイトからインストールでもOK\n\n\n\n上手くいかなければ、以下のWebサイトからもインストール可能です。 https://git-scm.com\n\n\n次に、gitを視覚的に使えるようにするgitクライアントです。この解説では、Visual Studio Code (以下VSCode)を使用します。VSCodeは、エディタ（ソースコードを書くためのソフト）として極めて優秀ですが、ここでは、gitの管理用に用意します。\n別記事（VSCodeの使い方）としてまとめてありますので、この記事を参考にインストールしてください。"
  },
  {
    "objectID": "learning/git/setup.html#vscodeへの拡張機能の導入",
    "href": "learning/git/setup.html#vscodeへの拡張機能の導入",
    "title": "環境構築",
    "section": "VSCodeへの拡張機能の導入",
    "text": "VSCodeへの拡張機能の導入\n次に、VSCodeでGitを使うための設定を行います。\nVSCodeは、拡張機能と呼ばれるアドインを入れることで、より使いやすくなります。Gitを使いやすくするために、二つの拡張機能を入れます。\n一つ目、Git Graphは、Gitの変更履歴全体をより視覚的に分かりやすくしてくれます。\n二つ目、Git Historyは、個別のファイルの変更履歴をより分かりやすくしてくれます。\nいずれも以下の手順でインストールできます。\n\n左メニューから拡張機能ボタン（4つの四角マーク）を選ぶ。\n検索窓でGit Graph（またはGit History）を検索し、出てきた一番上の機能を拡張機能をインストールを押す。\n表示されていた「インストール」の表示が消えれば完了。"
  },
  {
    "objectID": "learning/git/setup.html#gitの初期設定",
    "href": "learning/git/setup.html#gitの初期設定",
    "title": "環境構築",
    "section": "Gitの初期設定",
    "text": "Gitの初期設定\n次に、Gitの初期設定を行います。\n\nVSCodeで適当なフォルダを開く\n左メニューから丸三つが線でつながれた「ソース管理」のボタンを押し、「ソース管理」画面を開く\n最初は「リポジトリを初期化する」と出てくるので、クリック（「Branchの発行」など違う表示が出てきた場合はこの手順は飛ばす）\n\n\n\nソース管理画面の右上にある「・・・」をクリックし、「変更」以外のチェックを外す（「表示」「表示と並べ替え」など違う表示が出てきた場合はこの手順は飛ばす）\n\n\n\nソース管理画面の右上に、縦線がいくつか並んでいる「View GitGraph」ボタンがあるのでこれを押して、「GitGraph」画面を開く。\n\nおそらくこの時点では「コミットがない Unable to load commits」というエラーが出てくるが、無視して「Dismiss」を押してよい。\n\n\n\n\nGitGraph画面の右上、歯車マークを押して、設定画面 Repository Settings を開く。\n中ほどにあるUser Details の部分を確認する。User Nameなどが表示されていれば、これ以降の処理はスキップしてよい。表示されていなければ、「Add User Details」を押す。\nユーザー情報を入力する画面が開くので、ユーザーネーム、メールアドレスを入力し、「Use Globally」にチェックが入っていることを確認して「Set User Details」を押す。\n\nユーザーネームはニックネームなどでも構いません。\n\n\n\n\n\n\n\n\n\nユーザー情報はターミナルからでも設定できる\n\n\n\ngitの初期設定（氏名とアドレスの設定）はPower Shellやターミナルから設定することも可能です。以下のようなコマンドでユーザーネーム、メールアドレスを設定します。\n\ngit config --global user.name \"適当なユーザーネーム\"\ngit config --global user.email \"mail_adress@mail.com\"\n\n\n\nこれで、Gitの初期設定は完了です。\nなお、今回使用した「ソース管理」の画面は、gitについての操作がまとめられた画面で、今後頻繁に使用するので覚えておいてください。\n\n\n\n\n\n\nなぜユーザー情報が必要？\n\n\n\n履歴を管理するだけなのにユーザーネームやメールアドレスの登録が必要というのは奇妙な気がします。\n実はこれは、gitが複数人以上での共同作業を前提に設計されているためです。共同作業においては、「誰がいつ何を変更したか」を明確にする必要があるため、区別のためにユーザー名やメールアドレスを入力することになっています。\nなお、メールアドレスを入力しても特にメールが届いたりすることはありません。また、ローカルで利用している限りは、これらの情報は共同作業を行うメンバー以外が目にすることもありません。\nただし、サーバー上で自身のgit上の履歴を公開する場合、これらのユーザーネームやメールアドレスは誰でも閲覧できる状況になります。サーバーを利用するつもりであれば、この点を念頭に登録しましょう。"
  },
  {
    "objectID": "learning/git/setup.html#vscodeのカスタマイズ",
    "href": "learning/git/setup.html#vscodeのカスタマイズ",
    "title": "環境構築",
    "section": "VSCodeのカスタマイズ",
    "text": "VSCodeのカスタマイズ\nVSCodeでGitを使いやすくするため、少しVSCodeの設定を操作します。\n\n上部メニューの「ファイル」→「ユーザー設定」→「設定」を選択し、設定画面を開く\n\n\n\n設定画面上部にある検索窓に「autofetch」と入力すると、「Git: Autofetch」という項目が下部に出てくるので、trueを選択\n\n\n\n同じく、設定画面上部にある検索窓に「Git Show Action Button 」と入力。3つのチェックボックスが並んでいる二つ目、「追跡リモートブランチがない場合に・・・(publish)」と書かれている項目のチェックは外しておく。\n\n\n以上で、VSCodeの初期設定は完了です。特に保存ボタンはないので、このまま設定画面は消して構いません。\n\n\n\n\n\n\nカスタマイズの意味\n\n\n\nautofetchは、サーバーと通信して他者による変更履歴等があれば自動的にgitの情報を更新する機能です。通信が増える以外にデメリットはないので、通常はtrueにしておいたほうが便利です。\nGit Action Buttonは、VSCodeのソース管理画面において、ボタン一つで様々な操作ができる便利な機能です。ただ、2つ目の項目はgitをローカルで使おうとする際には邪魔なだけの機能なので、混乱を避けるために外しておきます。"
  },
  {
    "objectID": "learning/git/setup.html#ホスティングサービスのアカウントの用意",
    "href": "learning/git/setup.html#ホスティングサービスのアカウントの用意",
    "title": "環境構築",
    "section": "ホスティングサービスのアカウントの用意",
    "text": "ホスティングサービスのアカウントの用意\n\n\n\n\n\n\nNote\n\n\n\nこの項目は、オンラインサーバーとの同期機能を使わない限り、スキップして構いません。\n\n\n最後に、オンラインサーバーを提供しているホスティングサービスにアカウントを作成しましょう。ここでは、GitHubのアカウントの作り方を例に挙げます。\nGitHub公式サイトを開き、右上の「Sign up」を押します。\n\n開いた画面でメールアドレス、パスワード、ユーザーネームを選びます。ユーザーネームは英数字とハイフンのみが使用できます。\n\nContinueを押した後は、指示に従いましょう。画像認証後、メールアドレスに届くコードを入力するように求められるはずです。\n最後に、登録したユーザーネームとパスワードでログインできれば完了です。\n\n  \n    prev\n    gitの考え方\n  \n  \n        up\n        git入門\n    \n  \n    next\n    コミットと変更履歴"
  },
  {
    "objectID": "learning/git/merge.html",
    "href": "learning/git/merge.html",
    "title": "マージとコンフリクト",
    "section": "",
    "text": "このページでは、ブランチにおけるコミットを他のブランチにも反映する手順についてみていきます。"
  },
  {
    "objectID": "learning/git/merge.html#マージ",
    "href": "learning/git/merge.html#マージ",
    "title": "マージとコンフリクト",
    "section": "マージ",
    "text": "マージ\nブランチの目的は、「安定版で計算したい」「新機能を開発したい」「バグを治したい」などの目的ごとに作業環境を丸ごと切り替えることでした。しかし、新機能の開発が完了したら、当然安定版にも反映したくなります。重要なバグの修正は、複数の作業環境それぞれに反映したいでしょう。\nあるブランチにおける変更を別のブランチにも取り込む操作を、マージ merge と呼びます。取り込まれる対象となるのは、2つのブランチが最後に分岐してから行われた全てのコミットです。つまり、取り込まれる側のブランチにおける全ての変更が反映されることになります。\nマージの操作は以下の通りです。\n\nまず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）\n次に、取り込みたいブランチラベルを右クリックし、「Merge into current branch」を選択\n\n\n\nMerge用の小さな画面が開く。上部に「… merge branch マージされるブランチ into 現在のブランチ」と表示されていることを確認して、「Yes, merge」を選択\n\n\nこの操作で、自動的に「Merge branch …」というメッセージを持つマージコミットと呼ばれるコミットが作成されます。マージコミットの左側では、マージされた側のブランチからマージしたブランチへと合流するラインがひかれます。マージコミットの中身を確認すると、マージされる側において分岐後に行われた全てのコミット（下の例では「黍団子のレシピの追加」と「おじいいさんおばあさんの黍団子の描写を追加」の二つのコミット）の内容が含まれているはずです。\n\n\n\n\n\n\n\nNote\n\n\n\nエラーメッセージが表示された場合は、次のコンフリクトを確認してみてください。\n\n\nマージには方向性がある点に注意してください。"
  },
  {
    "objectID": "learning/git/merge.html#チェリーピック",
    "href": "learning/git/merge.html#チェリーピック",
    "title": "マージとコンフリクト",
    "section": "チェリーピック",
    "text": "チェリーピック\n分岐後のすべての変更ではなく、あるブランチにおける特定のコミットのみを現在のブランチに取り込むこともできます。この操作を、チェリーピック cherry pick と呼びます。\n\n\n\n\n\n\ncherry pick = つまみ食い\n\n\n\ncherry pickとは、サクランボの熟したものだけを選んで食べる様から転じて、「つまみ食い」を意味する表現です。まさに、ほかのブランチにある特定のコミットだけつまみ食いしているわけです。\n\n\nチェリーピックの操作は以下の通りです。\n\nまず取り込む側のブランチにHEADを切り替える（ブランチ名のタグをダブルクリック）\n次に、取り込みたいコミットのメッセージなど、ブランチラベル以外のエリアを右クリックし、Cherry Pickを選択\n\n\n\ncherry pick用の小さな画面が開くので、「Yes, cherry Pick」を選択\n\nこの操作で、取り込みたいコミットがコミットメッセージなども新たに現在のブランチに追加されたはずです。しかし、マージのようなブランチの合流線は描かれません。\n\n\n\n\n\n\n\nNote\n\n\n\nエラーメッセージが表示された場合は、次のコンフリクトを確認してみてください。"
  },
  {
    "objectID": "learning/git/merge.html#編集の競合コンフリクト",
    "href": "learning/git/merge.html#編集の競合コンフリクト",
    "title": "マージとコンフリクト",
    "section": "編集の競合：コンフリクト",
    "text": "編集の競合：コンフリクト\nチェリーピックやマージは、二つの異なるブランチ間で行われた変更を統合する作業です。それでは、もし二つのブランチが同一のファイルを編集していた場合、どうなるでしょう？　この場合でも、変更が異なる箇所（例えばファイルの先頭と末尾）に行われている場合には、両方の変更がうまく残されます。しかし、もし同一の箇所が変更されていたり、ファイル自体が削除されている場合では、編集の競合：コンフリクトが発生します。\nコンフリクトが発生すると、以下のようなエラーメッセージが表示されます。\n\n「Dismiss」（却下）を選ぶと、マージコミットは作成されておらずマージ前に戻っているように見えますが、ソース管理画面ではすでにコミットメッセージが入力されており、その下部には「変更のマージ」というファイルがステージ済みのファイルなどとともに表示されているはずです。ここに記載されているファイルが、コンフリクトが発生したファイルです。クリックすると、コンフリクトの詳細を確認できます。\n\nコンフリクトの解決方法は、コンフリクトの原因と期待する解決策によって異なります。\n\n同一箇所への編集によるコンフリクトの解決\nコンフリクトの解決は簡単です。まず、コンフリクトが発生したファイルをクリックした際に右下に表示される「マージエディターで解決」を選択します。すると、「マージ：ファイル名」というタブが新たに開きます。\n\nこの画面では、上部の左側にマージされる側のブランチ、右側に現在のブランチのファイルの状態が示されています。スクロールバーでは、コンフリクトが発生した位置が黄色く表示されています（上の例では3か所）。画面下部では、コンフリクトを解決した後のファイルが表示されます。解決は、以下のいずれかの方法をとります。\n\nどちらかの変更を反映したい場合、反映したい側で「（現在のマシン/受信中）を適用する」ボタンを押す\n両方の変更を残したければ、両側で押すか、「組み合わせを宇井家入れる」を選ぶ\nどちらの変更も反映したくなければ、「無視する」を両側で選ぶ\n画面下部で手動で編集して解決することもできる\n\n解決済みになると、スクロールバー上の表示が黄色から灰色に変わります。全てのコンフリクトを解決後、画面右下の「マージを完了」を押します。これで、当該ファイルは「変更のマージ」から「ステージされている変更」に移動します。\n他にもコンフリクトが発生しているファイルがあれば、同様の手順で解決します。すべてのファイルが「ステージされている変更」に移動したら、続行ボタンを押します。これで無事マージは終了です。\n\n\n\nファイルの削除に伴うコンフリクトの解決\n一方ではファイルが削除、または移動されてしまっていることによるコンフリクトが起きることもあります。この場合、ソース管理画面で「変更のマージ」にあるファイルを選んでも、「マージエディターで解決」ボタンは表示されません。\nこの場合は、ファイルを右クリックし「変更をステージ」を選んでください。ファイルを削除するか残すかを選択できます。\n\n\nマージの中止\nコンフリクトが発生した場合、マージ自体を中止したいかもしれません。この場合、以下の手順でマージを中止できます。\n\nGitGraphの上部右端にあるRefreshボタンを押す\n「Uncommitted Changes」という表示が履歴の最上部に現れるので、右クリックし「Reset Uncommitted Changes」を選ぶ\nResetの確認画面が表示されるので、「Mixed」ではなく「Hard」を選び、「Yes, reset」を選択する\n\n\n以上の手順で、マージ前の状態に戻すことができます。"
  },
  {
    "objectID": "learning/git/merge.html#ブランチに基づく開発",
    "href": "learning/git/merge.html#ブランチに基づく開発",
    "title": "マージとコンフリクト",
    "section": "ブランチに基づく開発",
    "text": "ブランチに基づく開発\nここまで、ブランチを用いることで、複数の「作業環境」を目的ごとに作成、管理し、必要に応じてほかの作業環境へも変更内容を取り込めることを見てきました。しかし、実際のプロジェクトを進めるときには、具体的にはどのようにブランチを使用すればよいのでしょうか？\nブランチの利用には厳密なルールはありませんが、目安となる「ブランチ戦略」と呼ばれる運用手法がいくつか存在します。以下はその代表的なスタイルのひとつです。\n\n最も基本的なルールでの運用は、「main」「feature」「fix」の3種類のブランチに分ける方法です。\n\n「main」ブランチは、安定版（＝バグがない、実際に計算に活用する）です\n\n原則として、「main」ブランチには直接コミットしません\n\n新機能の開発は、「feature」ブランチ使用します\n\nまず「main」ブランチから「feature/機能名」ブランチを作成・分岐します。機能名の部分は、追加する機能の名称などにします（例:feature/seasonal_dynamics）\n「feature/機能名」上で開発を進めます。\n機能が完了し十分安定すれば、「feature/機能名」ブランチを「main」ブランチにマージし、機能を取り込みます\n\nバグ修正には、「fix」ブランチを使用します。\n\nまず「main」ブランチからバグ修正ブランチ「fix/バグ名」を作成・分岐します。バグ名の部分はfeature同様バグの内容です（例:fix/fitness_calc_error）\n「fix/バグ名」上でバグ修正を進めます\n修正が完了したら、「fix/バグ名」ブランチを「main」ブランチ（必要に応じて他の「feature/機能名」ブランチ）にマージし、修正内容を取り込みます\n\n\nつまり、ファイルの編集・バグ修正はすべてmainから枝分かれしたfeature・fixブランチ上で行い、mainブランチはマージによってのみ進むことになります。\n\nより安定性を重視するケースでは、安定版の前に開発版「develop」を置くこともあります。この場合、運用ルールは以下のように変わります（変更点は太字）。\n\n「main」ブランチは、安定版（＝バグがない、実際に計算に活用する）です\n\n原則として、「main」ブランチには直接コミットしません\n\n新機能の開発は、「feature」ブランチ使用します\n\nまず「develop」ブランチから「feature/機能名」ブランチを作成・分岐します\n「feature/機能名」上で開発を進めます。\n機能が完了し十分安定すれば、「feature/機能名」ブランチを「develop」ブランチにマージし、機能を取り込みます\n\n「develop」ブランチが十分安定したら、「main」ブランチにマージする\nバグ修正には、「fix」ブランチを使用します。\n\nまず「main」ブランチからバグ修正ブランチ「fix/バグ名」を作成・分岐します。バグ名の部分はfeature同様バグの内容です（例:fix/fitness_calc_error）\n「fix/バグ名」上でバグ修正を進めます\n修正が完了したら、「fix/バグ名」ブランチを「main」ブランチ（必要に応じて「develop」ブランチや「feature/機能名」ブランチ）にマージし、修正内容を取り込みます\n\n\nこのケースでは、「develop」ブランチが「main」ブランチへのマージの前に挟まることで、より「main」ブランチの安定性を高めることができます。\n\nこのようなルールを用いることで、ブランチごとの役割が明確になり、開発の流れや履歴が把握しやすくなります。\n\n\n\n\n\n\n研究におけるブランチ戦略\n\n\n\nただし、上記はあくまで目安です。例えば、研究に用いるプログラムの場合は、個々の計算時のパラメータ設定等の編集に使うブランチである「analysis/計算目的」や、論文発表用にコードを整えるためのブランチ「release/論文名」などを作成してもよいかもしれません。\n\n\ngitにおいて、ブランチは気軽に作成・削除するものです。重要なことは、mainブランチはあくまで安定版として残しておくことです。新しい改良を思いついたら、とりあえずfeatureブランチを切って試してみる、くらいの気軽さで使ってみましょう。上手くいけばマージすればいいし、仮に失敗してもそのまま放置しておけばよいのです。運が良ければ、後で気が向いてもう一度そのブランチを触ってみる気になるかもしれません。\n\n    \n        prev\n        ブランチ\n    \n  \n        up\n        git入門\n    \n    \n        next\n        サーバーとの同期"
  },
  {
    "objectID": "learning/git/concept.html",
    "href": "learning/git/concept.html",
    "title": "gitの考え方",
    "section": "",
    "text": "gitは、ソースコードやテキスト、htmlファイルなど「文字」で記述するファイルの変更履歴を管理するために広く使われている、バージョン管理ツールです。\n使い方は非常にシンプルです。任意のフォルダをgitに管理させると、そのフォルダ内の全ファイルの変更を自動的に検出してくれるようになります。ユーザーがやることは、変更内容ごとに簡単なタイトルを付けて記録（commitと呼びます）していくだけです。これだけで、\n\n以前記録（commit）した任意のタイミングにフォルダの中身を戻す\n特定の時期に行った変更のみを取り消す\n特定のファイルの変更履歴を調べる\n\nといったことができます。\nさらに、オンラインサーバーと同期させることで、\n\n新しいPCからでも簡単に作業中のフォルダを復元\n複数人で同時にファイルを編集・同期\n\nなどもできるようになります。\n\n\n\n\n\n\nオンラインストレージと同じ？\n\n\n\ngitの機能だけ見ると、GoogleDriveやDropboxのようなオンラインストレージサービスと類似しているように思うかもしれません。しかし、gitには以下の特徴があります。\n\n極めて軽量。アプリとして常駐することはなく、ほとんどの機能はオンライン環境も必要としない。\n「ファイル自体」ではなく「変更履歴」の記録に特化しているため、「特定の期間にどのファイルが変更されたか」「このファイルはいつどこが書き換えられたか」等が簡単にわかる。\n複数の「作業環境」の管理機能が充実しており、同時並行で複数のバージョンを開発したり、一方のバージョンでの変更を他方へ丸ごと反映したりできる。\n画像ファイルや音楽ファイルなどの「文字」ではないデータの保存は苦手（不可能ではないが、変更を重ねると動作が重くなる）。\n\nつまり、様々なファイルをバックアップ・同期したいだけならオンラインストレージ、一つのプロジェクトを少しずつ発展・開発していく際のファイル管理をしたいならgit、という使い分けになるかと思います。"
  },
  {
    "objectID": "learning/git/concept.html#gitとは",
    "href": "learning/git/concept.html#gitとは",
    "title": "gitの考え方",
    "section": "",
    "text": "gitは、ソースコードやテキスト、htmlファイルなど「文字」で記述するファイルの変更履歴を管理するために広く使われている、バージョン管理ツールです。\n使い方は非常にシンプルです。任意のフォルダをgitに管理させると、そのフォルダ内の全ファイルの変更を自動的に検出してくれるようになります。ユーザーがやることは、変更内容ごとに簡単なタイトルを付けて記録（commitと呼びます）していくだけです。これだけで、\n\n以前記録（commit）した任意のタイミングにフォルダの中身を戻す\n特定の時期に行った変更のみを取り消す\n特定のファイルの変更履歴を調べる\n\nといったことができます。\nさらに、オンラインサーバーと同期させることで、\n\n新しいPCからでも簡単に作業中のフォルダを復元\n複数人で同時にファイルを編集・同期\n\nなどもできるようになります。\n\n\n\n\n\n\nオンラインストレージと同じ？\n\n\n\ngitの機能だけ見ると、GoogleDriveやDropboxのようなオンラインストレージサービスと類似しているように思うかもしれません。しかし、gitには以下の特徴があります。\n\n極めて軽量。アプリとして常駐することはなく、ほとんどの機能はオンライン環境も必要としない。\n「ファイル自体」ではなく「変更履歴」の記録に特化しているため、「特定の期間にどのファイルが変更されたか」「このファイルはいつどこが書き換えられたか」等が簡単にわかる。\n複数の「作業環境」の管理機能が充実しており、同時並行で複数のバージョンを開発したり、一方のバージョンでの変更を他方へ丸ごと反映したりできる。\n画像ファイルや音楽ファイルなどの「文字」ではないデータの保存は苦手（不可能ではないが、変更を重ねると動作が重くなる）。\n\nつまり、様々なファイルをバックアップ・同期したいだけならオンラインストレージ、一つのプロジェクトを少しずつ発展・開発していく際のファイル管理をしたいならgit、という使い分けになるかと思います。"
  },
  {
    "objectID": "learning/git/concept.html#何が嬉しい",
    "href": "learning/git/concept.html#何が嬉しい",
    "title": "gitの考え方",
    "section": "何が嬉しい？",
    "text": "何が嬉しい？\ngitの活用は、研究のような「試行錯誤を繰り返す」場合に様々な面でメリットがあります。\n\n新しいアイデアを試すとき、躊躇なく既存のシミュレーション用のソースコードを上書きできる。もし失敗してもすぐ元通り。\n「計算させつつ機能も追加したい」時も安心。シミュレーション用と機能追加用、二つの作業環境を作成して切り替えながら進められる。\n急に動かなくなったとき、計算にバグが見つかったときに、「何を変更したか」「いつからそのバグがあったか」を後で簡単に調べることができる。\n研究過程、すなわち「いつ何をやったのか」を逐一記録する実験ノート代わりになる。\n研究論文を公開する際に、計算に用いたプログラムを一般公開できる。\n複数人での共同研究も簡単。「他の人はどんなふうに書き換えた？」「どのくらい今進んでそう？」といったことが一目でわかる。\n\n使い捨てのコードを除けば、研究で使用するコードは全てgitに管理させるべきだと言えます。"
  },
  {
    "objectID": "learning/git/concept.html#gitの構成",
    "href": "learning/git/concept.html#gitの構成",
    "title": "gitの考え方",
    "section": "gitの構成",
    "text": "gitの構成\ngitを機能させるために必要なものは三つです。\n一つ目は、gitを機能させるためのアプリで、これ自体もgitと呼ばれます。詳しいインストール方法は次ページで説明します。ただ、このアプリはCUIと呼ばれる「全てキーボードでコマンドを入力して操作する」タイプのため、慣れないと使いにくいです。\nそこで出てくるのが二つ目、gitクライアントと呼ばれるアプリです。これらのアプリは、gitをマウスなどでより直感的に操作するためのものです。いくつか選択肢があります。\n\nSourceTree：古くからよく使われる無料アプリです。資料も多く見やすいため悪くはないのですが、やや動作が重いです。\nGitHub Desktop：後述するGitHubと呼ばれる大手サーバーが提供するgitクライアントです。\nGitKraken：一部機能が有料ですが非常に使いやすいです。\nVisual Studio Code【本サイトで使用】：優秀な無料コードエディタですが、拡張機能の導入で非常に優秀なgitクライアントとしても使用できます。\n\n三つ目が、ホスティングサービスと呼ばれる、Git用のオンラインサーバーを提供するサービスです。こちらもいくつかの選択肢があります。いずれも多人数で大規模な開発を行わない限り、無料で利用できます。次ページで説明するように、このサイトではGitHubを例に説明します。サービスによって無料で利用できる範囲に差がありますが、大きく差があるわけではないこと、ホスティングサービスの乗り換えも比較的簡単なことから、ひとまず適当に選び、ある程度gitのことが理解できた時点で改めてメインで使うサービスを比較検討しても良いと思います。\n\nGitHub【本サイトで使用】\nGitLab\nBitBucket\n\n\n    \n        up\n        git入門\n    \n  \n        up\n        git入門\n    \n    \n        next\n        環境構築"
  },
  {
    "objectID": "learning/git/branch.html",
    "href": "learning/git/branch.html",
    "title": "ブランチ",
    "section": "",
    "text": "このページでは、複数の作業環境を管理するための機能「ブランチ」について説明します。"
  },
  {
    "objectID": "learning/git/branch.html#今どこにいるかhead",
    "href": "learning/git/branch.html#今どこにいるかhead",
    "title": "ブランチ",
    "section": "今どこにいるか？：HEAD",
    "text": "今どこにいるか？：HEAD\ngitでは「現在のフォルダの中身は変更履歴上のどのタイミングのものか」、つまり現在のフォルダの状態のことをHEADと呼びます。HEADの位置は、GitGraph上では「○」で表示され、コミットメッセージが太字になります。\n\nHEADの位置を変えることで、フォルダの中身を丸ごと過去の状態に戻すことができます。この操作をcheckoutと呼びます。HEADの位置を変えるには、GitGraph上の適当なコミットメッセージの上で右クリックし、「Checkout」を選びます。警告が出ると思いますが、無視して「Yes, checkout」を選んでください。\n\nすると、HEADを示す「○」の位置、太字のコミットが切り替わったはずです。エクスプローラーからファイルを開くと、ファイルの中身がこのコミット時点の状態に戻っているのが確認できるはずです。このように、HEADの位置を動かすことで、gitは任意の時点のフォルダを簡単に復元することができます。試しに、いくつかのコミットをチェックアウトして、最新の状態から一番最初の状態まで、フォルダの中身を切り替えられることを確認してください。\ncheckoutを使ってHEADを動かせばフォルダの中身を巻き戻すことはできますが、実は普段の操作では特定のコミットへのcheckoutはほとんど行うことはありません。これは、gitにはブランチと呼ばれるより便利な仕組みがあるためです。"
  },
  {
    "objectID": "learning/git/branch.html#履歴の枝分かれブランチ",
    "href": "learning/git/branch.html#履歴の枝分かれブランチ",
    "title": "ブランチ",
    "section": "履歴の枝分かれ：ブランチ",
    "text": "履歴の枝分かれ：ブランチ\nここまで、コミットは一本の履歴上に連なっていました。しかし、このような履歴が一本道の構造だと以下のような問題が起きます。\n\nある機能のために変更したら、他の機能にも影響を与えて動かなくなってしまった\nある機能の開発のために行われた変更がどれなのか、変更履歴から見つけにくい\nバグが発生したことに気づいたが、いろいろ触りすぎていてどの変更が原因かわかりにくい\n\nこれらの問題は、「安定して利用したい」「バグを治したい」「新しい機能を追加したい」など、異なる目的での変更作業をすべて同じ履歴の中で行ってしまっていることが原因です。\nそこで、gitでは目的ごとに作業環境を丸ごと切り替えるための機能として、ブランチが用意されています。イメージとしては「機能A開発用の環境」「機能B開発用の環境」「バグの修正環境」「計算に使う安定版環境」それぞれにブランチを用意し、目的に応じて切り替えながら履歴を伸ばしていくような使い方です。\nGitGraphで見ると、最新のコミットに main と書かれたラベルがついています。実は、これまではデフォルトの「main」という名称のブランチを利用していました。\n\nブランチは必要に応じて自由に作ることができます。ブランチを作る際には、まず作業環境として履歴上のどのタイミングのフォルダ状態（すなわち、どのコミット）から始めるかを選択します。新しくブランチを作るには、GitGraph上で選択するコミットのメッセージ上で右クリックし、Create Branchを選択します。ポップアップに適当な名前を入力して「create branch」を選ぶと、新たなブランチが作成されます。\n\n\n\n\n\n\n\nブランチを「切る」\n\n\n\n新たなブランチを作成することを、俗に「ブランチを切る」とも呼びます。\n新しく作成するのに「枝を切る」のは少し不思議な気がしますが、おそらく小切手を切る、伝票を切るのような「発行する」意味合いでの表現が転じたものと思われます。\n\n\n現在のフォルダの状態HEADは、GitGraph上でブランチのラベルをダブルクリックすることで切り替えることができます。HEADがあるブランチは、ブランチラベルが太字になります。画面下ステータスバーの左端にも現在HEADがあるブランチが表示されています。\n\ncheckoutを使ったとき同様、HEADの移動に伴ってフォルダの状態も切り替わっていることを確認してください。つまり、ブランチを切り替えることで、フォルダの状態を瞬時に切り替えられるのです。\n\n\n\n\n\n\nHEADの移動=checkout\n\n\n\nブランチをダブルクリックする操作自体も「checkout」と呼びます。移動先がコミットでもブランチでも、HEADの移動はすべてcheckoutなのです。\n\n\n新たなコミットは、現在HEADがあるブランチに対して反映されます。例えば、先ほど作成した「kibidango」ブランチにHEADがある状態で新たな変更をコミットすると、kibidangoブランチが一つ進み、mainブランチと履歴が「枝分かれ」します。つまり、kibidangoブランチ上では、mainブランチには影響を与えることなく、編集しコミットを行えるわけです。\n\nこのように、ブランチは目的ごとの「作業環境」として機能します。目的ごとにブランチを作成することで、他のブランチには影響を与える心配をせず、その目的に集中して更新作業を行うことができるわけです。\n\n\n\n\n\n\nHEAD≠コミット上の位置\n\n\n\n上でも少し触れましたが、HEADの位置は「コミット」の場合と「ブランチ」の場合、両方があります。\n例えば、ブランチのラベルをダブルクリックせず、そのブランチがあるコミットをcheckoutすると、HEADはコミット上にある状態になります。この時、ブランチ名は太字にならず、ステータスバーにもブランチ名が表示されません（代わりにコミットIDと呼ばれる16進数が表示されています）。\n\nこれは、HEADが単にコミットの位置情報なのではなく、「今から行う変更はどのブランチに反映するか」を決めるものだからです。わかりやすいのは複数のブランチが同一のコミット上にある場合でしょうか。以下の例の場合、「kibidango」ブランチと「onitaiji」ブランチが両方同じコミット上にあり、この例では「onitaiji」ブランチ上にHEADがあることがわかります。この場合、新たなコミットは「onitaiji」ブランチに追加されます。\n\nこのように、ブランチの選択はコミットを置く先の選択という点でも重要です。\nなお、HEADがブランチにない状態でもコミット自体は可能ですが、この状態でのコミットは履歴が孤立しやすく、後で見失う可能性があるため、通常は避けるべきです（後述）。特定のコミットへのcheckoutは、せいぜい「一時的に過去のファイルの中身を確認するため」に使うくらいにとどめ、原則として通常はHEADはブランチに置きましょう。新たにHEADにしたいコミットが存在するなら、多くの場合そのコミットに新たなブランチを作成すべきです。"
  },
  {
    "objectID": "learning/git/branch.html#不要なブランチの削除",
    "href": "learning/git/branch.html#不要なブランチの削除",
    "title": "ブランチ",
    "section": "不要なブランチの削除",
    "text": "不要なブランチの削除\nブランチが不要になった場合、ブランチラベルを右クリックし「Delete Branch」を選ぶことで削除することができます。なお、現在HEADを置いているブランチは削除できないので、まず別のブランチにHEADを移してから削除しましょう。\nなお、そのブランチより先に他のブランチ等がない状態でブランチを削除すると、そこまでの履歴も一緒に消えてしまいます（正確には非表示になる：下記参照）。履歴の内容を失いたくない場合は、ブランチを削除してはいけません。\n\n\n\n\n\n\n履歴が消える？\n\n\n\n履歴の保存を目的としているgitでは、過去のコミットが消えてしまうことはほぼありません。しかし、過去のコミットすべてを表示していると、履歴表示が煩雑になることがあるため、gitでは基本的に「使用されない」コミットは非表示となります。具体的には、当該コミットより先にブランチがなく、タグ（特定のコミットに着けられるマーク、のちのページで扱います）もない状態では、非表示となります。\n例えば、以下の状態で「kibidango」ブランチを削除すると、上の三つのコミットは非表示となります。これは、ブランチを削除したことで、これら三つのコミットの先にブランチがなくなってしまうためです。\n\n同様の事故は、ブランチではなくコミットにHEADを置いている場合に良く起きます。以下の例では最初のコミットにHEADを置いてから、いくつかのコミットを追加した状態です。\n\nこの状態では、追加された最新の二つのコミットはどのブランチにも属していないため、mainやkibidangoなどのほかのブランチにHEADを移すだけで履歴から消えてしまいます。\n\nこれが、HEADは基本としてブランチに置くべき理由です。checkoutを使ってHEADをコミットに置いてしまうと、ブランチへの切り替えだけで簡単に履歴が消えてしまうのです。\n非表示になってしまっても、あわてる必要はありません。GitGraphの右上にある歯車マークの「設定」を開き、「Include commits only mentioned by reflog」にチェックを入れてください。 \nこれで、非表示になっているものも含めてすべてこれまでのすべてのコミットが表示されます（下図右）。非表示の場合（下図左）と比べて表示されるコミットが大きく増えているのがわかるでしょうか。\n\n\n\n\n    \n        prev\n        コミットと変更履歴\n    \n  \n        up\n        git入門\n    \n    \n        next\n        マージとコンフリクト"
  },
  {
    "objectID": "index_en.html#research-experiences",
    "href": "index_en.html#research-experiences",
    "title": "Koichi Ito",
    "section": "Research Experiences",
    "text": "Research Experiences\n\n2024-present Faculty of Science and Engineering, Doshisha University, Japan.  Associate Professor\n2022-2024 Faculty of Environmental Earth Science, Hokkaido University, Japan.  Assistant Professor\n2021-2022 International Institute for Zoonosis Control, Hokkaido University, Japan.  Postdoctoral Research Fellow, PI: Ryosuke Omori\n2017-2021 Department of Zoology, University of British Columbia, Canada.  Postdoctoral Research Fellow, PI: Michael Doebeli\n2016-2017 College of Life and Environmental Science, University of Exeter, UK.  Associate Research Fellow, PI: Andrew Higginson\n2015-2016 Department of Biology, Kyushu University, Japan.  JSPS Postdoctoral Research Fellow, PI: Yoh Iwasa\n2012-2015 Center for Ecological Research, Kyoto University, Japan.  Ph.D. (Science), Advisor: Atsushi Yamauchi\n2010-2012 Center for Ecological Research, Kyoto University, Japan.  M.S. (Science), Advisor: Atsushi Yamauchi\n2006-2010 Division of Biology, Faculty of Science, Kyoto University, Japan.  B.S. (Science)"
  },
  {
    "objectID": "index_en.html#membership-of-professional-societies",
    "href": "index_en.html#membership-of-professional-societies",
    "title": "Koichi Ito",
    "section": "Membership of Professional Societies",
    "text": "Membership of Professional Societies\n\n2010-present Japanese Society for Mathematical Biology\n2010-present The Ecological Society of Japan\n2011-present The Society of Population Ecology\n2015-present The Society for the Study of Species Biology"
  },
  {
    "objectID": "index_en.html#contact",
    "href": "index_en.html#contact",
    "title": "Koichi Ito",
    "section": "Contact",
    "text": "Contact\n koito [ΑΤ] mail.doshisha.ac.jp\n koichi.ito.bio [ΑΤ] outlook.com"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "伊藤公一",
    "section": "",
    "text": "捕食者・被食者の関係、花と送付者のような共生関係、個体間での助け合いと争い・・・人間同様生物の世界でも「利害の対立」が頻繁に生じています。私はこの生物における利害の対立に注目して生き物の行動や進化、社会関係について理論的な視点から研究をしています。\n\n\n数理生態学　進化生物学　動物行動学　ゲーム理論　データサイエンス"
  },
  {
    "objectID": "index.html#経歴",
    "href": "index.html#経歴",
    "title": "伊藤公一",
    "section": "経歴",
    "text": "経歴\n\n2024年-現在　同志社大学理工学部環境システム学科 准教授\n2022-2024年　北海道大学地球環境科学研究院 特任助教\n2021-2022年　北海道大学人獣共通感染症国際共同研究所バ 研究員 (PI: 大森亮介)\n2017-2021年　カナダ　ブリティッシュコロンビア大学動物学部 研究員 (PI: Michael Doebeli)\n2016-2017年　イギリス　エクセター大学生命環境カレッジ 研究員 (PI: Andrew Higginson)\n2015-2016年　九州大学理学部 学振特別研究員 (巌佐庸研究室)\n2010-2015年　京都大学生態学研究センター 修士課程・博士課程 (山内淳研究室)\n2006-2010年　京都大学理学部理学科"
  },
  {
    "objectID": "index.html#受賞歴",
    "href": "index.html#受賞歴",
    "title": "伊藤公一",
    "section": "受賞歴",
    "text": "受賞歴\n\n2023年 日本数理生物学会第18回研究奨励賞受賞\n2015年 第47回種生物シンポジウム ポスター賞受賞"
  },
  {
    "objectID": "index.html#所属学会",
    "href": "index.html#所属学会",
    "title": "伊藤公一",
    "section": "所属学会",
    "text": "所属学会\n\n2010年-現在　日本数理生物学会\n2010年-現在　日本生態学会\n2011年-現在　個体群生態学会\n2015年-現在　種生物学会"
  },
  {
    "objectID": "index.html#担当講義",
    "href": "index.html#担当講義",
    "title": "伊藤公一",
    "section": "担当講義",
    "text": "担当講義\n\n生物学基礎\n動物行動学\n生命の科学（数理生物学）\nプログラミングI\nプログラミングII\n環境システム基礎実験A\n環境システム応用実験A"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "伊藤公一",
    "section": "Contact",
    "text": "Contact\n koito [ΑΤ] mail.doshisha.ac.jp\n koichi.ito.bio [ΑΤ] outlook.com"
  },
  {
    "objectID": "lab.html",
    "href": "lab.html",
    "title": "生態情報解析研究室",
    "section": "",
    "text": "木の形から鳥の群れの動き、花と昆虫の関係から人間の行動に至るまで、自然界で見られる様々な生物の振舞いや姿形は、長い進化の過程の中で互いに影響を及ぼしあい競い合う中で生まれたものです。生態情報解析研究室では、そうした生物間相互作用が引き起こす現象に注目し、数学や計算機の力を借りて、そうした行動や現象を引き起こしたメカニズムを解明する「数理生態学」と呼ばれる分野の研究に取り組んでいます。\n生き物の見せる不思議な振る舞いや姿形の背後にある理由について、数学の力を借りて研究してみませんか？\n  \n\n\n\n卒研配属を考える学生の皆さんへ\n\n数理生態学分野は、調査や実験も必要としない分、アイデア次第で様々な生物が関わる現象を研究することができます。卒業研究のテーマは、ぜひ興味のある生物・現象に合わせて一緒に考えましょう。\n研究の半分は、計算式を解いたりプログラミングしたりが中心となります。「プログラミングI」および「プログラミングII」の履修が望ましいですが、これらの知識について学ぶ意欲があれば歓迎します。\n生物の知識ももちろん重要です。必須ではありませんが、以下の科目の履修が望ましいです。\n\n動物行動学\n生命環境科学\n生態学\n保全生態学\n生物資源学\n\n研究室内でのディスカッションを重視しています。議論好きの人、しっかり人の話が聞ける人、どちらも大歓迎です。\n\n興味はあるが自信がない、どんなことができるのか知りたい、という方は気軽に連絡してください。本研究室以外の選択肢も含めて相談に乗ります。\n\n\n卒業論文のテーマ例\n以下に例示するような様々な生態現象に注目し、数値解析、シミュレーションを用いてその適応的意義について解明する研究を行ってもらいます。\n\n渡り鳥はいつ渡りを始めるべきか\n餌の量に応じて魚はどのように個体間での闘争行動をどのように変えるか\n植物は日光を巡る競争の中でどのように振舞うか\nセミやカエルは、なぜ一斉に鳴き始めるのか\n花と送粉者の間の共生関係にともなってどのような進化が生じるか\n人間を始めとした生物における協力的な振る舞いはどのような条件で進化するか\n\n\n\nこれまでの卒業研究\n\n2025年度\n\n育児休業取得のため、卒業研究生の募集は行いません。\n\n\n\n2024年度\n\n川副哲平「子育て環境に着目した鳥類のヒナ殺しの進化的条件の解明」\n神野孝弥「資源をめぐる闘争の理論モデルにおけるコスト関数の一般化」"
  },
  {
    "objectID": "learning/git/commit.html",
    "href": "learning/git/commit.html",
    "title": "コミットと変更履歴",
    "section": "",
    "text": "このページでは、gitの基本操作である「変更履歴の記録」と「過去の履歴の確認」の操作について見ていきます。"
  },
  {
    "objectID": "learning/git/commit.html#リポジトリの初期化",
    "href": "learning/git/commit.html#リポジトリの初期化",
    "title": "コミットと変更履歴",
    "section": "リポジトリの初期化",
    "text": "リポジトリの初期化\ngitにおけるバージョン管理の単位はフォルダです。任意のフォルダを指定すると、そのフォルダ内の全てのファイルにおける変更履歴の管理を行います。この管理の単位を「リポジトリ」と呼びます。\n\n\n\n\n\n\n適切なリポジトリのサイズ\n\n\n\nフォルダが管理単位なので、一つのフォルダの中に様々なプログラムやドキュメントを入れれば、丸ごと一つのリポジトリで変更履歴を管理できることになります。\nしかし、通常は、プログラムごと、あるいはプロジェクトごとに一つのリポジトリを作って管理します。これは、あまりに複数の関連性の薄いプロジェクトをまとめて一塊の履歴として管理してしまうと、更新履歴の中から今注目しているプロジェクトに関する変更を見つけるのが難しくなってしまうためです。\n\n\ngitで新たなフォルダの変更履歴を管理し始めるには、そのフォルダにおいて「リポジトリの初期化」処理が必要です。この操作は、新しいフォルダを管理の対象にするたびに一度だけ実行する処理です。フォルダは空でも構いませんし、すでにいくつかのファイルがあってもかまいません。\n\nまず、VSCodeを使って管理の対象とするフォルダを開く。\n左メニューから「ソース管理」（丸三つが線でつながれたボタン）を開きます。\nソース管理画面に表示されている「リポジトリを初期化する」ボタンを押すと、表示が「コミット」と切り替わります。これで初期化完了です。\n\nVSCodeの設定を行っていない場合「Branchの発行」と表示されますが、無視してかまいません。"
  },
  {
    "objectID": "learning/git/commit.html#ファイルの変更",
    "href": "learning/git/commit.html#ファイルの変更",
    "title": "コミットと変更履歴",
    "section": "ファイルの変更",
    "text": "ファイルの変更\nリポジトリの初期化が済めば、あとは好きにそのフォルダ内のファイルを編集して構いません。gitはフォルダ内を監視し、変更があれば自動的に検出します。前回の状態からの「差分」を監視しているので、VSCodeを使わずに変更した内容でも問題なく検出してくれます。\n試しにいくつかのファイルを編集し、保存してみてください。変更されたファイルがある場合、ソース管理ボタン上に青いバッジで表示されるはずです。バッジ中の数字は、変更されたファイルの数を表しています。ソース管理の画面を開くと、変更されたファイルの一覧が表示されているはずです。\n\n\n\n\n\n\n\n未保存に注意！\n\n\n\n保存されていない状態だとソース管理には表示されませんので、必ず保存できているか確認してください（ファイルタブの右端が通常の閉じるボタン×ではなく●となっていると未保存です）。\n\n未保存のファイルがあると、左メニューのエクスプローラボタンの上に未保存のファイル数が青いバッジで表示されます。後述のステージ＆コミット操作を行う際は、バッジがついていないことを確認する癖をつけておきましょう。\n\n\nクリックすると「ファイル名（作業ツリー）」という名前の新たなタブが開きます。このタブでは、変更内容が赤（削除）と緑（追加）で表示されています。右端には、ファイル全体の変更位置についてスクロールバーに重ねて同じく赤と緑で表示されています。\n\nファイル自体の追加・削除も変更の一種として扱われます。ソース管理画面では、ファイルの横につくアルファベットで「U:新規ファイル(Untracked)」「M:変更されたファイル(Modified)」「D:削除済ファイル(Deleted)」を区別することができます。\n\n\n\n\n\n\n\nファイルの編集はエクスプローラから\n\n\n\nソース管理の画面から開けるのは、あくまで変更履歴を確認するためのファイル（作業ツリー）です。編集を行う場合は、エクスプローラ（左サイドメニューの一番上のファイルボタンからファイルを開きましょう。"
  },
  {
    "objectID": "learning/git/commit.html#履歴の記録ステージとコミット",
    "href": "learning/git/commit.html#履歴の記録ステージとコミット",
    "title": "コミットと変更履歴",
    "section": "履歴の記録：ステージとコミット",
    "text": "履歴の記録：ステージとコミット\nファイルの編集が一通り済んだタイミングで、変更履歴を手動で記録する必要があります。この履歴の記録は「ステージ」と「コミット」、二つの操作によって成り立っています。\n\n\n\n\n\n\n自動で履歴が記録されないのは？\n\n\n\n自動で履歴が記録されないのは一見不便に思うかもしれませんが、これは編集中などの中途半端なタイミングで多数の履歴が残り、結果として後でどの履歴を確認すればよいか分からなくなるのを避けるためにこうした仕組みになっています。\n\n\n\nステージ\n「ステージ」は記録する変更内容を選択する操作です。ソース管理画面には編集した全てのファイルが表示されますが、これら全ての変更を一度に記録する必要はなく、どの変更を記録するかまず選ぶわけです。\n\nステージするには、「変更」にあるファイルにオンマウスした際に右側に表示される「＋」マークをクリック、または右クリックで表示される「変更をステージ」を選択します。これで、「ステージされている変更」にファイルが移動します。\n\n\n\nステージを取り消す場合は、「ステージされている変更」にあるファイルにオンマウスした際に右側に表示される「ー」マークをクリック、または右クリックで表示される「変更のステージング解除」を選択します。これで、「変更」にファイルが戻ります。\n\n\n\n\n\n\n\n\nファイルの複数選択も可能\n\n\n\nファイル数が多い場合、ステージやステージの取消操作は、CtrlやShiftで複数ファイルを選択してから右クリックで操作すると楽です。\n\n\n\n全ファイルの変更をステージしたければ、「変更」の行自体にオンマウスした際に右側に表示される「＋」マークをクリック、または右クリックで表示される「すべての変更をステージ」を選択します。\nファイル丸ごとではなく、各ファイルの内部の変更毎にステージすることもできます。ファイルをクリックして「ファイル名（作業ツリー）」タブを開き、変更したい行を選択後左側に表示される「＋」マークをクリックします。\n\n\n\n\nコミット\n記録したい内容をステージできたら、次に 「コミット」でgitに変更履歴として記録します。この際、簡単な変更内容についてのメモをコミットボタンの上にある「メッセージ」欄に入力します。端的に何を変えたのかが後から振り返ってわかる記述が良いでしょう。\n\nメッセージを入力し「コミット」ボタンを押すことで、その時ステージされている変更履歴が記録されます。\n\n\ngitの普段の操作は、この「ステージ」と「コミット」の繰り返しです。ある程度まとまった変更を行ったら、キリが良いタイミングでコミットをする習慣をつけるのが、gitの利用の第一歩です。"
  },
  {
    "objectID": "learning/git/commit.html#履歴を見る",
    "href": "learning/git/commit.html#履歴を見る",
    "title": "コミットと変更履歴",
    "section": "履歴を見る",
    "text": "履歴を見る\n過去にコミットした変更履歴は、いつでも確認することができます。VSCodeの標準機能は機能として不十分なため、ここでは拡張機能としてインストールしたGit Graphを利用します。「GitGraph」画面は以下のいずれかの操作で開けます。\n\nソース管理画面の上部にある三つの点が複数の曲線でつながれた「Git Graph」ボタンをクリック\n画面下部ステータスバーの左側にある「Git Graph」の文字をクリック\n\n\nGitGraph画面では、下から上へとコミット操作によって保存された変更履歴が表示されています。\n\n各履歴をクリックすることで、そのコミットによってどのファイルが変更されたか表示される。\n\n表示された履歴中のファイルをクリックすると、そのファイルの変更内容自体も表示される。\n\n\n\n\n複数の履歴の間に行われた全変更を調べるには、ある履歴をクリックした後、D別の履歴をCtrlキーを押しながらクリック\n\nファイルごとの履歴も、同じく拡張機能としてインストールしたGit Historyで調べることができます。以下のいずれかの操作でファイルの履歴一覧表示できます。\n\nファイルを開いていると右上に表示される「時計」マークをクリック\nファイル名を右クリックして表示される「Git: View File History」を選択\n\nコミットを選択後、「Previous」ボタンを押すと、どのように変更されたかが表示されます。"
  },
  {
    "objectID": "learning/git/commit.html#変更の破棄と取消",
    "href": "learning/git/commit.html#変更の破棄と取消",
    "title": "コミットと変更履歴",
    "section": "変更の破棄と取消",
    "text": "変更の破棄と取消\nファイルを変更してみたものの納得がいかない場合、元に戻すことができます。状態に合わせて、いくつかの方法があります。\n\nコミット前の変更を破棄したい\nコミットする前の状態であれば、ソース管理画面でステージボタン「＋」の横にある変更を破棄ボタン「↶」を押すと、そのファイルの変更すべてが打ち消されます。ステージの場合と同様、ファイルの中の特定の部分だけ選択して変更を破棄することもできます。\n\n\n\nコミット後、特定のコミットの内容を取り消したい\nすでにコミットした変更を取り消したい場合、リバートRevertを使います。\n\nGitGraphを開き、打ち消したいコミットメッセージの上（mainと書かれたマークの上だとうまくいきません）で右クリック\nメニューから「Revert」を選ぶと確認画面が出るので、「Yes, revert」を選択\n\n\n以上の操作で、「Revert “…”」というメッセージの新たなコミットが自動的に追加されます。このコミットは対象のコミットの全変更を打ち消すような変更を行うもので、結果としてリバート対象のコミットがなかったような状態になります。\n\n\n\n\n\n\n\n取消なのに新しいコミットが追加される？\n\n\n\n取り消そうとしたのに新しいコミットがさらに追加される、というのは不思議に思うかもしれませんが、これは「取り消し自体も一つの変更として履歴に記録するべき」というGitの考え方を反映した動作です。\n\n\n注意点として、Revertは特定のコミットの打ち消し操作であり、特定の時点まで戻す操作ではありません。例えば、3つ前のコミットをRevertしても、1つ前、2つ前のコミットの変更は反映されたままです。3つ前の段階まで戻すには、3つのコミットすべてをRevertする必要があります。\nなお、リポジトリの状態をあるコミットの時点まで戻す方法は、目的に応じていくつかあります（checkout、reset）。これらの方法はブランチの概念を学ぶ必要があるため、次ページ以降で触れます。\n\n\n\n\n\n\n良いコミットの区切り方\n\n\n\nここまでコミットは「ファイルの編集が一通り済んだタイミングで行う」としか説明してきませんでした。実際はどの程度まで編集したときにコミットすればよいのでしょう？\nこの答えは状況にもよりますが、上で触れた「コミットの打ち消し」Revert操作が一つの目安になります。\nもし一つのコミットにあまりに多くの変更が含まれていると、Revertした際に本来は戻したくない変更まで取り消されてしまいます。一方で、あまりに一つ一つのコミットが細切れだと、あとから取り消そうと思ったときにいくつものコミットをRevertする必要が出てくるかもしれません。\n「この変更は単独でRevertできるか？」を自問しながらコミットを作ると、適切なコミットの頻度が見えてくるでしょう。\n\n\n\n    \n        prev\n        環境構築\n    \n    \n        up\n        git入門\n    \n    \n        next\n        ブランチ"
  },
  {
    "objectID": "learning/git/remote.html",
    "href": "learning/git/remote.html",
    "title": "サーバーとの同期",
    "section": "",
    "text": "このページでは、ブランチにならぶ重要な機能であるサーバーとの同期についてみていきます。"
  },
  {
    "objectID": "learning/git/remote.html#なぜサーバーが必要か",
    "href": "learning/git/remote.html#なぜサーバーが必要か",
    "title": "サーバーとの同期",
    "section": "なぜサーバーが必要か",
    "text": "なぜサーバーが必要か\nここまで、gitを手元のPCの中だけで使用してきました。しかし、gitはオンラインサーバーと同期させながら使用するのが一般的です。\nサーバーを使うメリットは大きく以下の4つです。\n\nバックアップ：PCの記録が失われたとしても容易に復元可能。\nPC間の同期：複数のPCの間で、作業環境を同期。\nチーム開発：複数メンバーでの共同開発に際してコード・履歴を共有。\n公開：ソースコードやドキュメントを容易に一般公開・配布できる。\n\nサーバーは自前のものを用意することもできますが、一般にはホスティングサービスと呼ばれるgitサーバーを利用します。\n※ 事前に環境構築などを参考に、ホスティングサービスのアカウントを作成しておいてください。本ページでは、GitHubでの操作例を示します。\n\n\n\n\n\n\nオンラインストレージにgitリポジトリを作るのは危険\n\n\n\nバックアップやPC間の同期が目的なら、OneDriveやGoogleDriveなどのオンラインストレージを使えばよいと思った人もいるかもしれません。\nしかし、オンラインストレージ内にgitリポジトリを作成するのはお勧めしません。これは、gitがオンラインストレージの同期機能と衝突し、最悪履歴の破損などが起きる可能性があるためです。\ngitリポジトリのバックアップ・PC間の同期は、素直にgitサーバーとの同期機能を使いましょう。変更のコンフリクトの解決などはgitのほうが高機能なので、PC間の同期に限ってもgitを使う価値はあります。"
  },
  {
    "objectID": "learning/git/remote.html#ローカルとリモートの紐つけ",
    "href": "learning/git/remote.html#ローカルとリモートの紐つけ",
    "title": "サーバーとの同期",
    "section": "ローカルとリモートの紐つけ",
    "text": "ローカルとリモートの紐つけ\ngitでは、手元のPC環境をローカル、サーバー環境をリモートと呼びます。\ngitサーバーを利用する際には、まずローカルとリモートを紐付ける作業が必要です。ケースごとに必要な操作を説明します。\n\n\nケース1：ローカルにすでにリポジトリがある\n手元のPCにはすでにリポジトリはあるが、途中でサーバーも利用したくなった場合、まずリモートにリポジトリを作成後、ローカルにリモートを登録します。\n\nリモートに新しいリポジトリを作成する。\n\ngithubの場合、トップページのメニューから「Repositories」を選び、「New」を押す。\nリポジトリ名を決める。半角英数字とアンダーバー、ハイフンのみ。\nコードを公開するか（Public）、非公開にするか（Private）を選択。どちらでも問題ない（下記参照）。\n画面下部の「Create repository」を押せば作成完了。\n\n\n\n\n\nhttpsから始まるリモートリポジトリのURLをコピー。\n\ngithubの場合、作成後に表示される画面に表示されている。右側のボタンを押せばコピー完了。\n\n\n\n\nVSCodeに戻り、「ソース管理」画面の設定メニューから「リモート」→「リモートの追加」の順に選択\n\n\n\n画面上部にURLの入力を求められるので、コピーしたリモートリポジトリのURLを入力し、「URLからリモートを追加する」を選択\n\n\n\nリモート名の入力を求められる。「github」などでも構わないが、慣習では「origin」とする。\nあとは、リモートにブランチがないにそって同期したいブランチを順にリモートへとアップロード。\n\n\n\n\n\n\n\nリポジトリはpublic? private?\n\n\n\nリポジトリの公開範囲、特に理由がなくとも「恥ずかしいから」とprivateとしておきたくなるところですが、publicと比較してのデメリットがいくつかあります。\n\nサービスの制限：無料アカウントでは、privateリポジトリの利用に制限が課せられている場合がある（共同作業可能な人数、作成できる個数など）\n\n2025年現在、GitHubにはprivateリポジトリに大きな制約はないが、しばしば条件は更新されるため、気になる場合は調べることをお勧めする\n\n実績紹介の機会の喪失：GitHubはじめ、ホスティングサービスのアカウントは、「これまでどんなコードを書いてきたか」を証明する手段として使われる。非公開とすると、そうした実績が外部に見えず機会損失にもなる。\n他者への貢献機会の喪失：どんなにくだらないコードに見えても、そのコードが他の誰かの参考になることも。\n\nもちろん、研究で使うコードを研究発表前に他者に公開するのはややリスクがある行為でもあります。すべてをpublicにする必要はありませんが、privateの方が常に良いわけではないことは押さえておきましょう。\nなお、「恥ずかしい」に関して言えば、GitHubにはすでに無数の「コードの練習用」のリポジトリが登録・公開されているので、あまり気にしても意味がないかもしれません。\n\n\n\n\n\nケース2：リモートにすでにリポジトリがある\n手元にコードはないが、どこかのサーバーにはすでにリポジトリが用意されている場合です。新しいPCで作業を始めるケース、他者が作成したプロジェクトを引き継ぐ場合などが該当します。この場合、ローカルにリモートリポジトリをダウンロードする「クローン Clone」という操作を行います。\n\nまず、対象のリモートリポジトリのURLをコピー（自分または他人のリポジトリ）\n\ngithubの場合、リポジトリを開いた際に表示される「&lt;&gt; Code」ボタンを押すと、URLが表示される。\n\n\n\n\nVSCodeをフォルダを開いていない状態にする。すでにいずれかのフォルダを開いている場合、「ファイル」→「フォルダを閉じる」から閉じる。\n「ソース管理」を開き、「リポジトリをクローンする」を選択\n画面上部にURLの入力を求められるので、コピーしたリモートリポジトリのURLを入力し、「リポジトリのURL」を選択\n\n\n\nクローンしたリポジトリを置くフォルダを選択。なお、選択したフォルダ内に、リポジトリと同名のフォルダが作成され、その中にリポジトリの中身が配置されます。\n\n例：prjフォルダを選択してmomotaroリポジトリをクローンすると、リポジトリの中身はprj/momotaro/の中に置かれます。\n\n必要に応じて、ローカルにブランチがないにそって、リモートのブランチを落としてくる。\n\n\n\n\nケース3：一から始める\nまだリモートにもローカルにもリポジトリがない、gitによる管理を新たに始めるケースです。すでに書きかけのコード等があってもかまいません。手順としては、ケース1とケース2の組み合わせ、すなわち「リモートリポジトリを作成」後「ローカルにクローン」\n\nケース1の手順1,2に従って、新たなリモートリポジトリを作成し、リモートリポジトリのURLをコピー\nケース2の手順2,3,4,5に従って、リモートリポジトリをローカルにクローン\nローカルにブランチがないにそって、リモートのmainブランチをローカルに落としてくる。\nすでに書きかけのコード等があれば、このタイミングでローカルにファイルを追加し、コミットする。\n\n新たに研究プロジェクトをスタートする場合、ひとまずリモートリポジトリを作成してクローンしてくる癖をつけておくと良いと思います。"
  },
  {
    "objectID": "learning/git/remote.html#同期プッシュとプル",
    "href": "learning/git/remote.html#同期プッシュとプル",
    "title": "サーバーとの同期",
    "section": "同期：プッシュとプル",
    "text": "同期：プッシュとプル\n\n同期はブランチ単位\nリモートとローカルの同期は、ブランチ単位で管理されます。つまり、ローカルの「mainブランチ」とリモートの「mainブランチ」はそれぞれ個別にフォルダの状態が履歴上で管理されており、同期操作はこの二つのブランチ間で行われます。\n\n\n\n\n\n\n同期は手動？\n\n\n\nコミット同様、同期も自動では行われず、手動で行う必要があります。これは、作業中にリモートからの同期によって作業環境が変わってしまうのを防ぐためです。例えば、共同作業をしている誰かがリモートのリポジトリ上でファイルを消すと、自動同期によって作業中の自分のファイルも消えてしまうかもしれません。\n手動であれば、後述するように変更のコンフリクトによって警告され、双方の変更のどちらを選ぶか（あるいはどちらも残すか）を選択することができます。\n\n\nGitGraphでは、以下のような3種類のブランチラベルでリモートとローカルのブランチが表示されます。\n\n「ブランチ名」：ローカルのブランチの状態\n 「リモート名/ブランチ名」：リモートのブランチの状態\n 「ブランチ名|リモート名」：ローカルとリモートの状態が同じ＝すでに同期されている\n\nつまり、表示が三つ目以外であれば、そのブランチは何らかの同期操作が必要な状況といえます。リモートとローカルの同期に使う操作は二種類です。以下、状況ごとに必要な操作を説明します。\n\nプル pull：リモートからローカルへコミットをダウンロード\nプッシュ push：ローカルからリモートへコミットをアップロード\n\n\n\n\n\n\n\nフェッチ Fetch：三つ目の操作\n\n\n\n実は、同期にかかわる操作としては、フェッチ Fetchと呼ばれるものもあります。これは、リモートやローカルのブランチの状態を更新せず、リモートにおける現在のブランチ状況のみ取得してくる操作です。Webブラウザの更新ボタンとほぼ同じ位置づけです。\nフェッチは動作も軽いため、この解説では環境構築においてAuto Fetchとよばれる設定を行いました。これは定期的（デフォルトでは3分毎）にフェッチをバックグラウンドで行う操作です。\nもし、Auto Fetchによる自動更新を待てない場合、ソース管理の「…」ボタンから、手動でフェッチを行う行うこともできます。\n\n\n\n\n\n\nA. ローカルよりリモートが先 → pull\n\n他の人（や他のPCからの操作で）リモートリポジトリが更新され、ローカルのファイル状態が古くなったケースです。この場合、リモートからコミット情報をダウンロードするプル pullが必要です。\n\nローカルにおける当該ブランチを選択（ローカルブランチラベルをダブルクリック）\nリモートブランチラベルを右クリックし、「Pull into current branch」を選択\nポップアップが出るが、「Yes, pull」を選択\n\n\n\n\nB. リモートよりローカルが先 → push\n\nローカルリポジトリ上でコミットを進めた結果、リモートのファイル状態が古くなったケースです。この場合、ローカルからリモートへコミット情報をアップロードするプッシュ pushが必要です。\n\nローカルブランチラベルを右クリック し、「Push branch」を選択\nポップアップが出るが、「Yes, push」を選択\n\n\n\n\nC. ローカルとリモートが分岐 → pull-push\n\nローカルとリモートの双方が更新された結果、履歴上で枝分かれしてしまったケースです。この場合、先に プル pullを行い、分岐を解消してから プッシュ pushを行うことが重要です。\n\nローカルにおける当該ブランチを選択（ローカルブランチラベルをダブルクリック）\nリモートブランチラベルを右クリックし、「Pull into current branch」を選択\nポップアップが出るが、「Yes, pull」を選択\n\nコンフリクトがない（つまり双方で行われた編集に競合がない）場合、自動的にマージが行われる。\nコンフリクトがある場合、手動でのマージ操作が必要となる。コンフリクトの解決方法を参考に解決する。\n\n無事マージが完了すれば、ローカルブランチラベルを右クリックし、「Push branch」を選択\nポップアップが出るが、「Yes, push」を選択\n\nまだリモートには反映したくない場合、手順4,5は省いて構いません。\n\n\n\nD. ローカルにブランチがない → checkout\n「リモート名/ブランチ名」というタグだけで、「ブランチ名」という同名のタグが見当たらない場合、そのブランチを触るためにはリモートからブランチを落としてくる必要があります。\n\nリモートブランチラベルをダブルクリック\nポップアップが出るので「Checkout Branch」を選択\n\n\n\n\nE. リモートにブランチがない → push\n「ブランチ名」というタグだけで、「リモート名/ブランチ名」という同名のタグが見当たらない場合、リモートにまだブランチがプッシュされていません。プッシュの方法は通常と同じです。\n\nローカルブランチラベルを右クリック し、「Push branch」を選択\nポップアップが出るが、「Yes, push」を選択\n\n\n\n\n\n\n\n\nボタン一つで同期\n\n\n\nここまでGitGraph上でのプッシュ、プル操作について説明してきました。実は、これらの操作は「ソース管理」画面の「コミット」ボタンより簡単に行うことができます。すべての変更がコミットされると、ブランチの状況に応じて必要なプッシュ・プルを行う「変更の同期」ボタンへと切り替わります。下矢印がプル、上矢印やプッシュが必要なコミットの数を示しています。\n\nしかし、この機能はボタン一つで操作できてしまうがゆえに、実際にブランチに対してどのような操作を行っているのかが非常に見えにくくなる欠点があります。複雑な操作を行うためには、ブランチが更新時にどのように動くか自体に慣れておく必要があるため、GitGraphの様子がボタンを見ただけで想像できるようになるまでは、このボタンは使わずGitGraph上での操作を練習することをお勧めします。"
  },
  {
    "objectID": "learning/git/remote.html#普段の操作の流れと注意点",
    "href": "learning/git/remote.html#普段の操作の流れと注意点",
    "title": "サーバーとの同期",
    "section": "普段の操作の流れと注意点",
    "text": "普段の操作の流れと注意点\n実際の開発時の流れは、以下のようになります。\n\nもし新しいプロジェクトをスタートさせる、新しいPCで作業を開始するときは、リモートリポジトリをクローンする\n作業を開始するブランチに切り替え check outする\nリモートが進んでいる場合、可能であればプル pullしておく\n編集作業を進め、ローカルリポジトリのコミットを進める\n作業がひと段落したら、プルの必要がないことを確認してからプッシュ push、またはリモートのいずれかのブランチにマージ mergeしておく\n\nポイントは、以下のような点です。\n\n競合が発生しない限りこまめにプル pullをしておく\n\n頻繁なpullで、不必要な編集内容の競合：コンフリクトが発生することを防ぐことができます。\n\n作業がひと段落した段階で、変更内容をpush/mergeしておく\n\npushしていないコミットがたまると、他者がそれらの変更をpullできず不必要な編集内容の競合：コンフリクトを引き起こします\n\nリモートのブランチを直接操作することはできない\n\nブランチのマージなども、ローカルでいったんそれぞれのブランチを操作した後、pushしてリモートに反映する\n\n\n\n\n\n\n\n\n複数人での共同作業\n\n\n\n複数人で一つのプロジェクトを進める場合、それぞれが自由にリモートリポジトリを操作するためには、リポジトリのコラボレーターに登録する必要があります。\nGitHubの場合は、以下のように操作します。\n\nGitHubにログインし、共同作業を行うリポジトリを開く\nSettingsのタブを押し、左メニューからCollaboratorsを選択\n画面の「Add people」ボタンから、相手のGitHubユーザー名、メールアドレスなどから検索し追加、またはメールで招待\n\n\nなお、複数人で共同作業をしても、他者のローカルのリポジトリの様子が見えることはありません。これは、個々のローカルはリモートとしかつながっていない（リモートを中心に個々のローカルが結びついている）ためです。\n\n\n\n    \n        prev\n        マージとコンフリクト\n    \n    \n        up\n        git入門\n    \n    \n        next\n        便利な機能"
  },
  {
    "objectID": "learning/git/usecase.html",
    "href": "learning/git/usecase.html",
    "title": "Koichi Ito web site",
    "section": "",
    "text": "実際の使い方の流れを見ていく。"
  },
  {
    "objectID": "learning/git/usecase.html#section",
    "href": "learning/git/usecase.html#section",
    "title": "Koichi Ito web site",
    "section": "",
    "text": "実際の使い方の流れを見ていく。"
  },
  {
    "objectID": "learning/git.html",
    "href": "learning/git.html",
    "title": "git入門",
    "section": "",
    "text": "gitとは、ドキュメントやソースコードなど、様々なテキスト形式のファイルの「履歴管理」をするためのツールです。特定のフォルダの中身における変更内容を保存し、必要に応じて過去の状態に戻すことができます。主にプログラムの開発に重点をおいて設計されており、ある程度複雑なプログラムを書く上ではなくてはならないツールです。\ngitの入門サイトなどを見ると、小難しいコマンドをターミナルで入力する方法が紹介されていることが多いですが、最初はとっつきにくいでしょう。このサイトでは、視覚的に容易に扱える方法として、Visual Studio Codeを使ったgitの利用を紹介します。\n\ngitの考え方\n環境構築\nコミットと変更履歴\nブランチ\nマージとコンフリクト\nサーバーとの同期\n便利な機能"
  },
  {
    "objectID": "learning.html",
    "href": "learning.html",
    "title": "資料",
    "section": "",
    "text": "プログラミング\n\nVSCodeの使い方 非常に軽量でありながら様々なOS・ファイル形式に対応する優れたエディタ、Visual Studio Code (以下VSCode)の使い方についてまとめました。\ngit入門 ドキュメントやソースコードのバージョン管理用ツール、gitをVSCodeを使って簡単に利用する方法をまとめました。\n\n\n\nC++の解説記事\nC++の解説記事をいくつか Qiita 上にて公開中です。特に以下の記事は、数値解析の際などに参考になるかもしれません。\n\nC++で常微分方程式入門 常微分方程式の数値解析用ライブラリ boost::odeint についての解説記事です。簡単につかえて、計算精度も計算速度もしっかり制御できる、非常に良くできたライブラリです。ルンゲクッタ法を自分で書くぐらいなら、ぜひ使うべきライブラリです。\nC++20 スマートポインタ入門 C++のメモリ管理の負担を軽減する、スマートポインタについての解説記事です。もし普段、動的メモリ確保、すなわちmalloc/freeやnew/deleteを書くことがあれば、この記事がお役に立てるかもしれません。C++11以降進化を続けてきたスマートポインタのC++20時代の使い方をまとめています。\nそれ、ポインタ使わなくてもできるよ：Ｃ言語のポインタとC++の流儀 ポインタに注目して書いた、C言語ユーザーやC++ビギナーへのC++入門記事です。\nC++で効率よく重複のない乱数列を生成する 実際に利用する場合に最も速いのはどうすべきか？の視点から、重複なし乱数列の生成アルゴリズムについて解説しています"
  },
  {
    "objectID": "publication.html",
    "href": "publication.html",
    "title": "業績",
    "section": "",
    "text": "[Koichi Ito - Google Scholar Citation]\n\nSpecialism and generalism in social animals in variable environments\nKoichi Ito, Andrew Higginson. 2025. Philosophical Transactions of the Royal Siciety B (380): 20230264.\n\n\nGeographic distribution of needle litter microfungi in British Columbia\nShunsuke Matsuoka, Koichi Ito, Takashi Osono. 2024. The Harris Science Review of Doshisha University (65-1): 8-16.\n\n\nHuman movement avoidance decisions during Coronavirus disease 2019 in Japan\nRyosuke Omori, Koichi Ito, Shunsuke Kanemitsu, Ryusuke Kimura, Yoh Iwasa. 2024. Journal of Theoretical Biology (585): 111795.\n\n\nTime changes of customer behavior on accommodation reservation: a case study of Japan\nKoichi Ito, Shunsuke Kanemitsu, Ryusuke Kimura, Ryosuke Omori. 2023. Japan Journal of Industrial and Applied Mathematics.\n\n\nCompetition model explains trends of long‐term fertilization in plant communities\nAtsushi Yamauchi, Koichi Ito, Shota Shibasaki. 2023. Ecology and Evolution (13-2): e9832.\n\n\nContinuous irregular dynamics with multiple neutral trajectories permit species coexistence in competitive communities\nAtsushi Yamauchi, Koichi Ito, Shota Shibasaki, Toshiyuki Namba. 2023. Theoretical Population Biology (149): 39-47.\n\n\nFuture behaviours decision-making regarding travel avoidance during COVID-19 outbreaks\nKoichi Ito, Shunsuke Kanemitsu, Ryusuke Kimura, Ryosuke Omori. 2022. Scientific Reports(12-1): 19780.\n\n\nIncorporating thermodynamics in predator–prey games predicts the diel foraging patterns of poikilothermic predators\nKoichi Ito, Andrew D. Higginson, Graeme D. Ruxton, Yannis P. Papastamatiou. 2021. Journal of Animal Ecology (00): 1-13.\n\n\nSterile males and females can synergistically suppress wild pests targeted by sterile insect technique\nYusuke Ikegawa, Koichi Ito, Chihiro Himuro, Atsushi Honma. 2021. Journal of Theoretical Biology (530): 110878.\n\n\nColonization process determines species diversity via competitive quasi‐exclusion\nAtsushi Yamauchi, Koichi Ito, Shota Shibasaki. 2021. Ecology and Evolution (00): 1-11.\n\n\nOn the importance of evolving phenotype distributions on evolutionary diversification\nGil J. B. Henriques, Koichi Ito, Christoph Hauert, Michael Doebeli. 2021. PLOS Computational Biology (17-2): e1008733 .\n\n\nEvolution of honest reward signal in flowers\nKoichi Ito, Miki F. Suzuki, Ko Mochizuki, 2021. Proceedings of the Royal Society B (288): 20202848.\n\n\nThe joint evolution of cooperation and competition\nKoichi Ito, Michael Doebeli, 2019. Journal of Theoretical Biology (480): 1-12.\n\n\nOptimal foraging by herbivores maintains polymorphism in defence in a natural plant population\nYasuhiro Sato†, Koichi Ito†, Hiroshi Kudoh, 2017. Functional Ecology (31-12): 2233-2243. † equal contribution\n\n\nThe evolution of cooperation by negotiation in a noisy world\nKoichi Ito, John McNamara, Atsushi Yamauchi, Andrew Higginson, 2016. Journal of Evolutionary Biology (30-3): 603-615.\n\n\nRelationship between aggregation of rewards and the possibility of polymorphism in continuous snowdrift games\nKoichi Ito, Hisashi Ohtsuki, Atsushi Yamauchi, 2015. Journal of Theoretical Biology (372):47-53.\n\n\nTheoretical study of evolution of polymorphism in the level of anti-herbivore defense in plants\nKoichi Ito, Atsushi Yamauchi, 2011. Journal of Plant Interactions (6):183-184."
  }
]